---
title: "Test of Ordinary Kriging"
output: html_notebook
---

Approach is based on the documentation here: https://rpubs.com/nabilabd/118172
This script provides a basic kriging approach as a benchmark for comparing different kriging methods and results. It performs simple Ordinary Kriging without incorporating additional covariates.

```{r}
# Load packages
# Spatial Data Handling & Processing
library("sf")      
library("sp")
library("terra")    
library("stars")   

# Spatial Analysis & Interpolation
library("gstat")  

# Data Manipulation & Wrangling
library("tidyverse")  # Includes ggplot2, dplyr, etc.
library("dplyr")
library("magrittr")  

# Data Visualization
library("ggplot2") 
library("scales")
library("gridExtra") 

# Mapping & Interactive Visualization
library("mapview") 
library("tmap")
```

Load the temperature measurements as input data

```{r}
# Read temperature points
temp <- read_sf('../data/sensor_data_20240107_31days.gpkg')

class(temp)
```

Pre-processing of the temperature data

```{r}
# Removes only rows where `temperature` is NA
temp <- temp[!is.na(temp$temperature), ]  

# Ensure dateobserved is in the correct date-time format
temp <- temp %>%
  mutate(dateobserved = as.POSIXct(dateobserved, format="%Y-%m-%d %H:%M:%S"))

# Calculate the mean temperature for each station in July
july_mean_temp <- temp %>%
  filter(format(dateobserved, "%m") == "07") %>%  # Keep only July
  group_by(stationname) %>%  # Group by individual station
  summarise(mean_temperature = mean(temperature, na.rm = TRUE), .groups = "drop")  # Compute mean

# View the result and class of the object
july_mean_temp
class(july_mean_temp)
```

Normalize temperature using elevation

```{r}
# Load the elevation data
dem <- rast("../data/hd_elev_32632.tif")

# Reproject the elevation data to match correct CRS
dem <- terra::project(dem,"EPSG:4326")
```

Get elevation information at point locations

```{r}
# Get elevation at the sites
elevation <- terra::extract(dem, july_mean_temp, buffer=0)

# Rename the extracted column to "elevation"
names(elevation)[names(elevation) != "ID"] <- "elevation"

# Add the elevation data to the temperature data
july_mean_temp$elevation <- elevation$elevation
```

Normalize the temperature data using elevation information

```{r}
# Degrees C per meter -> standard parameter, needs to further investigated for future
lapse_rate <- 0.0065  

# Sea level as reference station
reference_elevation <- 0  

# Adjust temperatures for elevation effect
july_mean_temp$norm_temperature <- july_mean_temp$mean_temperature + 
                             (reference_elevation - july_mean_temp$elevation) * lapse_rate
```

Transform temperature data to SpatialPointsDataFrame

```{r}
# Ensure the data has point geometry
if (st_geometry_type(temp)[1] == "POINT") {
  july_mean_temp <- as(july_mean_temp, "Spatial")
} else {
  stop("The dataset does not contain point geometry.")
}

class(july_mean_temp)
```

Get boundaries of bounding box to create grid for interpolation

```{r}
bbox(july_mean_temp)
```

Create a grid for the interpolation

```{r}
# Extract the bounding box from july_mean_temp
bbox_values <- bbox(july_mean_temp)

# Define the grid resolution
res <- 0.00009009  # ~10 meters in degrees (latitude or longitude)

# Create grid coordinates within the bounding box
x_range <- seq(bbox_values[1, 1], bbox_values[1, 2], by = res)  # Longitude (coords.x1)
y_range <- seq(bbox_values[2, 1], bbox_values[2, 2], by = res)  # Latitude (coords.x2)

# Create the grid from the longitude and latitude ranges
grid_points <- expand.grid(x = x_range, y = y_range)

# Convert to a spatial grid an create grid from the points
coordinates(grid_points) <- ~ x + y
gridded(grid_points) <- TRUE

# Assign the same CRS as the temp datato the grid
proj4string(grid_points) <- proj4string(july_mean_temp)

# Visualize the grid for checking
plot(grid_points, main = "Grid Surface over Bounding Box Area")
```

```{r}
# Extract coordinates from temp data (SpatialPointsDataFrame)
july_mean_temp_df <- as.data.frame(july_mean_temp)
july_mean_temp_df$x <- july_mean_temp_df$coords.x1  
july_mean_temp_df$y <- july_mean_temp_df$coords.x2

# Plot the points with measurements
plot1 <- ggplot(july_mean_temp_df, aes(x = x, y = y)) +
  geom_point(size = 1, color = "blue") +  
  coord_equal() + 
  ggtitle("Points with Temperature Measurements") +
  theme_minimal()  

# Extract coordinates from grid (SpatialPixels)
grid_points_df <- as.data.frame(grid_points)
grid_points_df$x <- grid_points_df$x
grid_points_df$y <- grid_points_df$y

# Plot the grid for interpolation
plot2 <- ggplot(grid_points_df, aes(x = x, y = y)) +
  geom_point(size = 1, color = "black") +  
  coord_equal() + 
  ggtitle("Points at Which to Estimate") +
  theme_minimal() 

# Arrange the plots side by side
grid.arrange(plot1, plot2, ncol = 2)
```

Histogram of data distribution for the calculated mean temperature

```{r}
hist(july_mean_temp$mean_temperature, breaks=20, main="Distribution of Mean Temperature in July", col="lightgrey")

plot(density(july_mean_temp$mean_temperature), main = "Density of Mean Temperature in July")
```

Compute experimental variogram and fit model to the data

```{r}
# Compute experimental variogram for log-transformed mean temperature
v = variogram(mean_temperature~1, july_mean_temp)

# Plot the sample variogram
plot(v)

# Fit an exponential variogram model to the sample variogram
lzn.fit <- fit.variogram(v, model = vgm(psill = 1.5, model = "Sph", range = 3.5, nugget = 0.05))

# Plot the sample variogram with the fitted model
plot(v, lzn.fit)
```

Run Ordinary Kriging

```{r}
# Perform kriging interpolation for log-transformed normalized temperature  
lzn.kriged <- krige(mean_temperature ~ 1, july_mean_temp, grid_points, model=lzn.fit)
```

Results of Ordinary Kriging

```{r}
# Convert kriging results to a data frame and visualize the predicted values
# Create a heatmap for the predicted values
lzn.kriged %>% as.data.frame %>%
  ggplot(aes(x=x, y=y)) + 
  geom_tile(aes(fill=var1.pred)) + 
  coord_equal() +
  scale_fill_gradient(low = "yellow", high="red") +
  scale_x_continuous(labels=comma) +
  scale_y_continuous(labels=comma) +
  theme_bw() +
  ggtitle("Kriging Prediction of Log-Transformed Elevation Normalized Temperature")
```

Plot the Kriging Variance (Uncertainty)
High variance areas indicate uncertainty in predictions.

```{r}
spplot(lzn.kriged["var1.var"], main = "Kriging Variance (Uncertainty Map)")
```

Investigate observed vs. predicted values
Are these values similar or are there big differences.

```{r}
# Extract predicted values at observed locations
july_mean_temp$predicted <- over(july_mean_temp, lzn.kriged)$var1.pred  # Assuming 'var1.pred' is the prediction column

plot(july_mean_temp$predicted, july_mean_temp$mean_temperature)
     xlab = "Observed"
     ylab = "Predicted"
     main = "Observed vs Predicted"
abline(0,1, col="red", lwd=2) # Ideal 1:1 line

sum(is.na(july_mean_temp$predicted))  # Count of NA values

# Keep only complete rows
clean_data <- july_mean_temp[complete.cases(july_mean_temp$predicted), ]

length(july_mean_temp$mean_temperature)
length(july_mean_temp$predicted)

# Compute R-squared & RMSE
cor(clean_data$mean_temperature, clean_data$predicted)
sqrt(mean((clean_data$mean_temperature - clean_data$predicted)^2))
```

Leave-one-out cross-validation

```{r}
# Perform leave-one-out cross-validation
lzn.kriged.cv <- krige.cv(log(norm_temperature) ~ 1, july_mean_temp, grid_points, model = lzn.fit)

# Extract the results
cv_results <- as.data.frame(lzn.kriged.cv)

# View the results
head(cv_results)
```

Explanation of the results:
- Predicted Values (var1.pred) are the model's best estimate of the temperature.
- Observed Values (observed) are the actual measurements.
- Residuals (residual) are the errors between predictions and actual measurements.
- Z-Scores (zscore) help to assess the significance of the residuals relative to expected variability.
- Prediction Variance (var1.var) indicates uncertainty in the model's predictions.

More information on z-scores:
- A z-score around 0 means the residual is within the expected range, i.e., the prediction error is not large in comparison to the variability. 
- A z-score far from 0 (e.g., > 2 or < -2) suggests a location where the model's prediction error is unusually large or small. These locations might warrant further inspection or could suggest areas where the model has poor performance.
- Positive z-scores indicate that the observed values are larger than the predicted values (underestimation by the model), and negative z-scores indicate the opposite (overestimation by the model).




Test Kriging approach from here: https://www.youtube.com/watch?v=hPYx-LqHShI&ab_channel=OneFourFourExplains
Pretty simple code for the same result. Here we just sampled a 1000 data points to check, how good the interpolation worked -> probably not the solution as a grid would be better suited.

```{r}
july_mean_temp_sp <- sp::SpatialPointsDataFrame(coords = st_coordinates(july_mean_temp), data = as.data.frame(july_mean_temp), proj4string = sp::CRS("+init=epsg:32632"))

head(july_mean_temp_sp)

samp = sp::spsample(x = july_mean_temp_sp, n = 1000, type = "random")

var = gstat::variogram(object = mean_temperature~1, locations = july_mean_temp_sp)
plot(var)

fit_var <- gstat::fit.variogram(var, model = gstat::vgm(model = "Exp"))


fit_var = gstat::fit.variogram(object = var, model = gstat::vgm(psill = 2.7, nugget = 0.05, range = 0.049, model = "Sph"))
plot(var, model = fit_var)

krig = gstat::krige(formula = mean_temperature~1, locations = july_mean_temp_sp, newdata = samp, model = fit_var)

head(krig@data)

tmap = tm_shape(shp = krig) + tm_dots(col = "var1.pred")
tmap
```

