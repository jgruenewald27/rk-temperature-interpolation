---
title: "test_kriging_sds"
author: "Johannes Gruenewald"
date: "2025-04-04"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Continue working on this. This is based on the spatial data science
course from Sven. Look at the two examples at the end of the kriging
section to get a feeling for the workflow Sven introduced and adapt it
to my data und questions. Understand the functionality, the data thats
needed and its format and try to replicate that for my use case.
<https://giscience.courses-pages.gistools.geog.uni-heidelberg.de/spatial-data-science/kriging.html#case-study-interpolation-of-temperature-data-in-germany>

Load packages

```{r}
#library(raster)
library(terra)
library(sf)
library(sp)
library(tmap)
library(gstat)
library(tidyverse)
```

Section for loading temperature data and pre-process it

Load the temperature data

```{r}
temp <- sf::st_read('../data/temp_HD/sensor_data_20240107_31days.gpkg')

summary(temp)
```

Filter the temperature data:

1\. Remove all rows with NA temperature values

2\. Filter for a specific timestamp

```{r}
# this chunk is based on the functionality of the dyplr package
# Remove rows where 'temperature' is NA
temp <- temp %>% filter(!is.na(temperature))
message("Number of missing values: ",sum(is.na(temp$temperature)))

# Define the start and end timestamps
start_time <- as.POSIXct("2023-07-01 15:00:00")
end_time <- as.POSIXct("2023-07-01 16:10:00")

# Filter for rows within the timestamp range, then group by 'stationname' and take the first row per group
temp <- temp %>%
  filter(dateobserved >= start_time & dateobserved <= end_time) %>%
  group_by(stationname) %>%
  slice_min(dateobserved, n = 1) %>%
  ungroup()
```

Reproject the temperature data

```{r}
temp <- st_transform(temp, crs="EPSG:32632")
st_crs(temp)
```

Load the covariates and pre-process it

Load DEM as covariate

```{r}
dem <- terra::rast("../data/DEM/hd_elevation_4326.tif")
```

Reproject DEM

```{r}
# Reproject raster to match temperature data
dem <- terra::project(dem, y = crs(temp))
```

Plot temperature information and elevation together

```{r}
tm_shape(dem) + 
  tm_raster(col="hd_elevation_4326", palette = "Greys", style= "fixed", breaks = c(50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600),
            title= "Elevation [m]") +
  tm_shape(temp) + tm_dots(col="temperature", size=.2, title ="Temperature [°C]") +
  tm_scale_bar() +
  tm_layout(attr.outside = TRUE, legend.outside = TRUE, main.title = "Temperature for the month of July")
```

Load Tree Canopy Height as covariate

```{r}
# Load the data
tree_canopy <- terra::rast("../data/Canopy_height/clip_Forest_height_2019_NAFR.tif")

# Mask out all values which are assigned to water and have value 101
# Not part of this area. But needs to be masked as well: 102 Snow/ice; 103 No data
tree_canopy[tree_canopy == 101] <- NA
```

Reproject Tree Canopy Height

```{r}
# Reproject raster to match temperature data
tree_canopy <- terra::project(tree_canopy, y = crs(temp))

# Check if the two covariates have the same crs
crs(tree_canopy) == crs(dem)
```

Plot temperature information and tree canopy height together

```{r}
tm_shape(tree_canopy) + 
  tm_raster(col="clip_Forest_height_2019_NAFR", palette = "Greys", style= "fixed", breaks = c(0, 5, 10, 15, 20, 25, 30, 35),
            title= "Tree Canopy Height [m]") +
  tm_shape(temp) + tm_dots(col="temperature", size=.2, title ="Temperature [°C]") +
  tm_scale_bar() +
  tm_layout(attr.outside = TRUE, legend.outside = TRUE, main.title = "Temperature for the month of July")
```

Resample tree canopy height raster to match resolution of elevation
raster 

- dem has a coarser resultion

```{r}
# Check the spatial resolution of both rasters
message("Resolution of Elevation data: ",res(dem))
message("Resolution of Tree Canopy Height data: ",res(tree_canopy))

# Resample tree_canopy to match the resolution and alignment of dem
tree_canopy_resampled <- resample(tree_canopy, dem, method = "bilinear")

# Combine dem and resampled tree_canopy into a single raster stack
raster_stack <- c(dem, tree_canopy_resampled)

message("Resolution of resampled data: ",res(raster_stack))
```

Adding covariates to temperature data

- Extract values from raster and add to temperature data

```{r}
# Extract raster values at the temp locations
elevation_values <- terra::extract(dem, temp)

# View the extracted values
print(elevation_values)

# Extract tree canopy height values at the temp locations
canopy_heigth_values <- terra::extract(tree_canopy_resampled, temp)

# View the extracted values
print(canopy_heigth_values)

# Use dplyr to add the extracted values as a new column in the sf object
temp <- temp %>%
  mutate(elevation = elevation_values[[2]])

# Use dplyr to add the extracted values as a new column in the sf object
temp <- temp %>%
  mutate(tree_canopy_height = canopy_heigth_values[[2]])

# Check the updated sf object
print(temp)
```

Explorative data analysis - check the effect of covariates 

- run linear model to check for effects in the data

```{r}
# Fit a linear model to assess the relationship between temperature and covariates
g <- lm(temperature ~ elevation + tree_canopy_height, data= temp)
summary(g)
```

Visual exploration of potential correlations between temperature and the selected covariates

```{r}
# Checking influence of elevation on temperature
ggplot(temp, mapping = aes(x=temperature, y=elevation)) +
  geom_point() + geom_smooth()

# Checking the influence of Tree Canopy Height on temperature
ggplot(temp, mapping = aes(x=temperature, y=tree_canopy_height)) +
  geom_point() + geom_smooth()
```

THIS MIGHT NEED FURTHER CONSIDERATION IF I WANT TO FINETUNE MY KRIGING APPROACH 

Create variogram map to spot anisotropy for temperature

```{r}
plot(variogram(temperature ~ 1, temp, map = TRUE, cutoff = 1000,  width = 100))
```

THIS ALSO NEEDS FURTHER ATTENTION OF THE FINAL KRIGING APPROACH

Plot directional variogram

```{r}
zn.v.dir <- variogram(temperature ~ 1, temp, alpha = (0:3) *  45) 
plot(zn.v.dir)
```

Create variogram

```{r}
tempHD.svar <- variogram(temperature ~ elevation + tree_canopy_height, 
                         data=temp)
plot(tempHD.svar)
```

Fit the variogram

```{r}
tempHD.vgm <- gstat::fit.variogram(tempHD.svar, 
                            model=vgm(model="Sph", nugget = 0.1	),
                                 fit.ranges=TRUE)
tempHD.vgm
```

Plot the fitted variogram

```{r}
plot(tempHD.svar, tempHD.vgm, pch="+", col="black", 
     main="Temperature, universal kriging")
```

Create prediction locations for the kriging process including the covariates

```{r}
# Convert raster to points, including values, and remove NAs
predLocations <- terra::as.points(dem, values=TRUE, na.rm=TRUE)

# Extract values from the tree canopy raster at the same points
canopy_vals <- terra::extract(raster_stack, predLocations)

# Join the extracted values back into the SpatVector
# Remove the .ID column since it just indexes the rows
predLocations <- cbind(predLocations, canopy_vals[, -1])

# Convert the points to a SpatialPointsDataFrame
predLocations <- as(predLocations, "Spatial")

# Mark the points as gridded, indicating they form a regular grid
sp::gridded(predLocations) <- TRUE

# Drop doubled elevation column
predLocations <- predLocations[, -1]

# Rename columns
names(predLocations) <- c("elevation", "tree_canopy_height")

# Display the updated gridded points
head(predLocations)
```

Run Universal Kriging

```{r}
predTempHD <- krige(temperature ~ elevation + tree_canopy_height, 
                    locations = as(temp, "Spatial"), 
                    newdata = predLocations, model =  tempHD.vgm)
```

Converting the output of the kriging prediction into a RasterBrick
object (multi-layer raster)

```{r}
predTempHDRas <- terra::rast(predTempHD)
```

Plot comparison of interpolated and observed temperatures 

```{r}
tm_shape(subset(predTempHDRas, subset = "var1.pred")) + 
  tm_raster(col="var1.pred", title = "Prediction [°C]", n=9, 
            legend.reverse = TRUE, palette = "-RdBu") +
  tm_shape(temp) + 
  tm_symbols(col="temperature", title.col = "Observed [°C]", 
             legend.col.reverse = TRUE, palette = "-BrBG", 
             border.col = "black", size=.1, alpha=.9) +
  tm_scale_bar() + 
  tm_layout(title = "Temperature interpolation, HD", 
            legend.outside = TRUE, attr.outside = TRUE)
```

Visualize the uncertainty of the kriging interpolation

```{r}
tm_shape(subset(predTempHDRas, subset = "var1.var") %>% sqrt()) + 
  tm_raster(col="var1.var", title = "Standard error [°C]", n=9, palette = "Purples") +
  tm_shape(temp) + 
  tm_symbols(col="temperature", title.col = "Observed [°C]", palette = "-BrBG", 
             border.col = "black", size=.1, alpha=.9) +
  tm_scale_bar() + 
  tm_layout(title = "Temperature interpolation, HD", 
            legend.outside = TRUE, attr.outside = TRUE)
```

THIS ALSO NEEDS FURTHER ATTENTION -> PROPERLY ASSESSING THE PERFORMANCE OF THE KRIGING APPROACH
IS OF GREAT IMPORTANCE AND NEEDS TO BE PRECISELY ANALYZED TO UNDERSTAND, WHICH APPROACH MIGHT THE 
MOST PROMISING

Cross-validation

Spherical variogram model

```{r}
tempSphCv <- krige.cv(temperature ~ elevation + tree_canopy_height, 
                      locations = as(temp, "Spatial"),
                      model =  tempHD.vgm, nfold=5)
```

Exponential variogram model

```{r}
tempHDExp.vgm <- fit.variogram(tempHD.svar,
                               model=vgm(model="Exp", 
                                         nugget = 0.1),
                                 fit.ranges=TRUE)

tempExpCv <- krige.cv(temperature ~ elevation + tree_canopy_height, 
                      locations = as(temp, "Spatial"),
                      model =  tempHDExp.vgm, nfold=5)
```

Mean error (bias), ideally this should be zero

```{r}
mean(tempSphCv$residual)
mean(tempExpCv$residual)
```

Mean square prediction error, ideally 0.

```{r}
mean(tempSphCv$residual^2)
mean(tempExpCv$residual^2)
```

Correlation observed and predicted, ideally 1

```{r}
cor(tempSphCv$observed, tempSphCv$observed - tempSphCv$residual)
cor(tempExpCv$observed, tempExpCv$observed - tempExpCv$residual)
```

Correlation predicted and residual, ideally 0

```{r}
cor(tempSphCv$observed - tempSphCv$residual, tempSphCv$residual)
cor(tempExpCv$observed - tempExpCv$residual, tempExpCv$residual)
```
