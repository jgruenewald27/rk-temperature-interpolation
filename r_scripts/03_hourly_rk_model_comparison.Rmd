---
title: "hourly_rk_model_comparison"
output: html_document
date: "2025-12-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load Required Libraries

# Spatial Data Handling & Processing
library(sf)
library(sp)
library(terra)
library(raster)
library(stars)
library(spdep)

# Spatial Analysis & Interpolation
library(gstat)
library(randomForest)
library(nlme)
library(automap)
library(mgcv)

# Data Manipulation & Wrangling
library(tidyverse)
library(dplyr)

# Data Visualization
library(ggplot2)
library(ggspatial)
library(scales)
library(gridExtra)
library(corrplot)

# Mapping & Interactive Visualization
library(tmap)

# Additional
library(lattice)
library(car)
```

--------------------------------------------------------------------------------

This script compares the selected hourly RK temperature prediction raster 
(timestamp: 2023-07-09 14:00) to the Stadtklima-Analyse reference surface for
the city of Heidelberg. It computes cellwise agreement metrics 
(correlations, bias, MAE, RMSE), visualizing maps and residual diagnostics 
(including land-cover–stratified performance), and finally quantifying 
July-wide temporal variability by contrasting the per-pixel mean/SD of stacked 
hourly RK predictions with a monthly mean RK surface.

--------------------------------------------------------------------------------

```{r Prepare OSM LULC}

# Read OSM LULC raster
osm_lulc  <- rast("../data/OSM_LULC/hd_osm_landuse_4326.tif")

# Assign class labels
lulc_classes <- data.frame(
  value = c(
    5,   # Water bodies
    11,  # Urban fabric
    12,  # Industrial, commercial and transport units
    13,  # Mine, dump and construction sites
    14,  # Artificial, non-agricultural vegetated areas
    21,  # Arable land
    22,  # Permanent crops
    23,  # Pastures
    31,  # Forests
    32,  # Shrub and/or herbaceous vegetation associations
    33,  # Open spaces with little or no vegetation
    41   # Wetlands
  ),
  class_name = c(
    "Water bodies",
    "Urban fabric",
    "Industrial, commercial and transport units",
    "Mine, dump and construction sites",
    "Artificial, non-agricultural vegetated areas",
    "Arable land",
    "Permanent crops",
    "Pastures",
    "Forests",
    "Shrub and/or herbaceous vegetation associations",
    "Open spaces with little or no vegetation",
    "Wetlands"
  )
)

# Convert to polygon
lulc_polygons <- as.polygons(osm_lulc, dissolve = TRUE)

# Save output as geopackage
writeVector(lulc_polygons, "../data/OSM_LULC/hd_osm_lulc_polygons.gpkg", overwrite = TRUE)
```

```{r Compare the Stadtklima-Analyse with my RK prediction surface}

# Load rasters and vector data
mod  <- rast("../RK_ANBH_07_2023_12days/rk_predictions/2023-07-09_1400_rk_prediction.tif")
ref5 <- rast("../data/stadtklimaanalyse_2023/2_22_074_ist_t14_rev01.tif")
river <- st_read("../data/waterways/waterways_HD.gpkg")                 
landuse <- st_read("../data/OSM_LULC/hd_osm_lulc_polygons.gpkg")
osm_lulc <- rast("../data/OSM_LULC/hd_osm_landuse_4326.tif")
hd_bounds <- sf::read_sf('../data/AOI/OSM_boundaries_HD.geojson')

# Check if model has CRS
if (is.na(crs(mod))) stop("`mod` has no CRS. Set it first.")

# Define CRS and project reference raster to model grid
crs_mod <- crs(mod, proj = TRUE)
crs(ref5) <- "EPSG:32632"
ref30 <- project(ref5, mod, method = "bilinear")
osm_lulc <- project(osm_lulc, mod, method = "near")

# Reproject vector layers to project CRS
hd_bounds <- st_transform(hd_bounds, crs = "EPSG: 32632")
crs_mod <- crs(mod, proj = TRUE)
river     <- st_transform(river,     crs = crs_mod)
landuse   <- st_transform(landuse,   crs = crs_mod)

# Crop and mask rasters by AOI
mod    <- mask(crop(mod,    vect(hd_bounds)), vect(hd_bounds))
ref30  <- mask(crop(ref30,  vect(hd_bounds)), vect(hd_bounds))
osm_lulc <- mask(crop(osm_lulc,  vect(hd_bounds)), vect(hd_bounds))

# Clip vector layers to AOI
river <- st_intersection(river, hd_bounds)
landuse <- st_intersection(landuse, hd_bounds)

# Verify alignment between datasets
stopifnot(terra::same.crs(ref30, mod))
print(st_crs(hd_bounds)$input)
stopifnot(isTRUE(all.equal(res(mod),  res(ref30))))
stopifnot(isTRUE(all.equal(ext(mod),  ext(ref30))))
stopifnot(isTRUE(all.equal(res(mod),  res(osm_lulc))))
stopifnot(isTRUE(all.equal(ext(mod),  ext(osm_lulc))))
```

```{r Model–Reference Temperature Comparison and Metrics}

# Select single-hour rasters
mod_h   <- mod    
ref30_h <- ref30       

# Apply common NA mask
both_mask <- !is.na(values(mod_h)) & !is.na(values(ref30_h))
mod_h[!both_mask]   <- NA
ref30_h[!both_mask] <- NA

# Extract cell values from both rasters
vr <- values(c(mod_h, ref30_h, osm_lulc))
colnames(vr) <- c("rk_temp", "ref_temp", "lu")
comparison_df <- as.data.frame(vr) |> drop_na()

# Calculate comparison metrics
pearson_r <- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "pearson")
spearman_r<- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "spearman")
bias_C    <- mean(comparison_df$rk_temp - comparison_df$ref_temp)
mae_C     <- mean(abs(comparison_df$rk_temp - comparison_df$ref_temp))
rmse_C    <- sqrt(mean((comparison_df$rk_temp - comparison_df$ref_temp)^2))

# Combine metrics for output
metrics <- c(
  pearson_r = pearson_r,
  spearman_r = spearman_r,
  bias_C = bias_C,
  MAE_C = mae_C,
  RMSE_C = rmse_C
)
print(metrics)

# Sample data if very large (for faster plotting)
set.seed(1)
comparison_plot_df <- if (nrow(comparison_df) > 1e6) {
  comparison_df[sample.int(nrow(comparison_df), 1e6), ]
} else comparison_df
```

```{r RK and Reference Temperature Map Visualization}

# Convert rasters to data frames for plotting  
mod_df  <- as.data.frame(mod_h,  xy = TRUE, na.rm = TRUE)
ref_df  <- as.data.frame(ref30_h, xy = TRUE, na.rm = TRUE)
names(mod_df)[3] <- "value"
names(ref_df)[3] <- "value"

# Compute shared color scale range  
mm_mod <- terra::minmax(mod_h)
mm_ref <- terra::minmax(ref30_h)
rng <- range(c(mm_mod, mm_ref), na.rm = TRUE)

# Convert vector layers to sf  
river_sf     <- st_as_sf(river)
hd_bounds_sf <- st_as_sf(hd_bounds)

# Plot RK model map  
p_rk_map <- ggplot() +
  geom_raster(data = mod_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "Temperature [°C]", limits = rng) +
  coord_sf() + 
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
  )

# Plot reference map  
p_ref_map <- ggplot() +
  geom_raster(data = ref_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "PET [°C]", limits = rng) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
  )




# Combine both plots with shared legend
# p_rk_ref <- (p_rk_map + p_ref_map +
#                     plot_layout(guides = "collect") &
#                     theme(legend.position = "right")) +
#   plot_annotation(
#     title = "Comparison of RK and Reference Temperature Maps — Heidelberg, 09-07-2023 14:00",
#     theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5,
#         margin = margin(b = 10)))
#   )

# Display combined plot
p_ref_map
p_rk_map

# Save as PNG
# ggsave("../plots_report/rk_14-00.png", p_rk_map, width = 8, height = 4, dpi = 300)
# 
ggsave("../plots_report/urban_model_14-00.png", p_ref_map, width = 8, height = 4, dpi = 300)
```

Short explanation of the following chunk:
The following chunk is a quality-control checkpoint. It doesn’t change the 
analysis output, but it ensures that what I compare is valid (same units, 
same grid, no hidden bias).
Keep it as a safety check but might omit it from the final report.

```{r Residual diagnostics and consistency checks}

# Residual summary (model-reference)
resid <- comparison_df$rk_temp - comparison_df$ref_temp
summary(resid)
mean(resid)        # mean bias
median(resid)      # median bias
mean(resid < 0)    # share of negative residuals
mean(resid > 0)    # share of positive residuals

# Unit consistency check
summary(comparison_df$rk_temp)
summary(comparison_df$ref_temp)
# Values ~280–320 → Kelvin; ~10–45 → Celsius
# A ~273.15 offset would indicate mixed units

# Spatial alignment check (CRS, resolution, extent)
stopifnot(terra::same.crs(ref30, mod))
stopifnot(isTRUE(all.equal(terra::res(ref30),  terra::res(mod))))
stopifnot(isTRUE(all.equal(terra::ext(ref30),  terra::ext(mod))))
```

Short interpretation of the residual summary metrics:
The RK model systematically overestimates temperatures by about +8.7 °C across
all grid cells, with no negative residuals. Both datasets are in °C and 
perfectly aligned spatially.

```{r Spatial Residual Map and Histogram}

# Residual histogram
p_resid_hist <- ggplot(data.frame(resid), aes(x = resid)) +
  geom_histogram(bins = 60, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth = 0.6) +
  labs(
    x = "Residuals [°C]",
    y = "Number of cells"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10, margin = margin(b = 5)),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(color = "grey85"),
    axis.title.x = element_text(margin = margin(t = 15)),
    axis.title.y = element_text(margin = margin(r = 15))
    )

# Recalculate spatial residuals (per grid cell) to retain geographic structure 
resid_raster <- mod_h - ref30_h

# Convert residual raster to data frame for ggplot visualization
resid_map_df <- as.data.frame(resid_raster, xy = TRUE, na.rm = TRUE)
names(resid_map_df)[3] <- "residual"

# Define symmetric color scale limits around zero
rmax <- ceiling(max(abs(terra::global(resid_raster, "min", na.rm = TRUE)$min),
                    abs(terra::global(resid_raster, "max", na.rm = TRUE)$max)))
# round to nearest multiple of 5 for clean legend breaks
rmax <- ceiling(rmax / 5) * 5  

# Plot spatial residual distribution
p_resid_map <- ggplot() +
  geom_raster(data = resid_map_df, aes(x = x, y = y, fill = residual)) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.5) +
  scale_fill_gradient2(
    name = "Residuals [°C]",
    low = "#2166ac", mid = "white", high = "#b2182b",
    midpoint = 0,
    limits = c(-rmax, rmax),
    breaks = seq(-15, 15, 5),
    labels = seq(-15, 15, 5)
  ) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, margin = margin(b = 8)),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 9),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  )

# Display the plots
p_resid_hist
p_resid_map

# Save as PNG
# ggsave("../plots_report/residual_histogram_rk_vs_reference_2023-07-09_14-00.png", p_resid_hist, width = 10, height = 5, dpi = 300)

# ggsave("../plots_report/residual_spatial_map_rk_vs_reference_2023-07-09_14-00.png", p_resid_map, width = 10, height = 4, dpi = 300)
```

```{r Robust Performance Metrics and Regression Fit}

# Robust central tendency
median_bias <- median(resid, na.rm = TRUE)

# Linear regression between reference and model temperatures
lm_rk_ref_temp <- lm(ref_temp ~ rk_temp, data = comparison_df)
summary(lm_rk_ref_temp)$coefficients 
summary(lm_rk_ref_temp)$r.squared    

# Print summary results
c(median_bias = median_bias, R2 = summary(lm_rk_ref_temp)$r.squared)
```

Short interpretation of the linear regression model results:
The analysis shows that the RK model reproduces the general spatial temperature 
pattern well (R² = 0.78) but consistently predicts higher absolute temperatures
than the reference. With a median bias of about +8.7 °C (in this case the same 
as mean_bias) and a regression slope of 2.7, the results indicate that the RK 
model is overall too warm and exhibits a narrower temperature range, under-
representing the spatial variability present in the reference data.

```{r Mean Temperature and Correlation by Landuse Class}

# Align raster CRS to land use polygons
mod_h   <- project(mod_h, landuse)
ref30_h <- project(ref30_h, landuse)

# Extract mean temperature per land use polygon
mod_vals <- terra::extract(mod_h, landuse, fun = mean, na.rm = TRUE)
ref_vals <- terra::extract(ref30_h, landuse, fun = mean, na.rm = TRUE)

# Add mean values to land use data
landuse$rk_mean  <- mod_vals[, 2]
landuse$ref_mean <- ref_vals[, 2]

# Calculate model–reference difference
landuse <- landuse %>%
  mutate(diff = rk_mean - ref_mean)

# Summarize by land use class
corr_by_class <- comparison_df |>
  group_by(lu) |>
  summarise(
    n = n(),
    pearson  = if (n >= 2) cor(rk_temp, ref_temp) else NA_real_,
    spearman = if (n >= 2) cor(rk_temp, ref_temp, method = "spearman") else NA_real_,
    bias     = mean(rk_temp - ref_temp),
    rmse     = sqrt(mean((rk_temp - ref_temp)^2))
  )
```

```{r Color Palette for CORINE Landcover}

# Define color palette for land cover classes based on OSM LULC
landcover_colors <- c(
  "Water bodies" = "#2daae1",

  "Urban fabric" = "#e6004d",
  "Industrial, commercial and transport units" = "#c04be6",
  "Mine, dump and construction sites" = "#8c2d8f",
  "Artificial, non-agricultural vegetated areas" = "#f1b6da",

  "Arable land" = "#ffffb2",
  "Permanent crops" = "#e68026",
  "Pastures" = "#d9ef8b",

  "Forests" = "#1a9850",
  "Shrub and/or herbaceous vegetation associations" = "#a6d96a",
  "Open spaces with little or no vegetation" = "#e0f3db",

  "Wetlands" = "#b2b2ff"
)

# Combination class number and name
lu_lookup <- c(
  "5"  = "Water bodies",

  "11" = "Urban fabric",
  "12" = "Industrial, commercial and transport units",
  "13" = "Mine, dump and construction sites",
  "14" = "Artificial, non-agricultural vegetated areas",

  "21" = "Arable land",
  "22" = "Permanent crops",
  "23" = "Pastures",

  "31" = "Forests",
  "32" = "Shrub and/or herbaceous vegetation associations",
  "33" = "Open spaces with little or no vegetation",

  "41" = "Wetlands"
)
```

```{r Correlation by land cover class}

# Add a factor column to your data
corr_by_class$lu_label <- factor(
  lu_lookup[as.character(corr_by_class$lu)],
  levels = names(landcover_colors)
)

corr_by_class <- corr_by_class %>%
  mutate(
    lu_label_n = paste0(lu_label, " (n = ", n, ")")
  )

# Plot correlation by land cover class
p_landcover_corr <- ggplot(
  corr_by_class,
  aes(
    x = reorder(lu_label_n, pearson),
    y = pearson,
    fill = lu_label
  )
) +
  geom_col(width = 0.6, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", pearson)),
    hjust = -0.1, size = 3
  ) +
  scale_fill_manual(values = landcover_colors) +
  coord_flip() +
  geom_hline(yintercept = 0, color = "grey50", linetype = "dashed") +
  labs(x = NULL, y = "Pearson Correlation (r)") +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15))
  )

# Display the plots
p_landcover_corr

# Save as PNG
# ggsave("../plots_report/landcover_correlation_2023-07-09_14-00.png", p_landcover_corr, width = 10, height = 5, dpi = 300)

# Plot correlation by land cover class
p_landcover_corr <- ggplot(
  corr_by_class,
  aes(
    x = reorder(lu_label_n, rmse),
    y = rmse,
    fill = lu_label
  )
) +
  geom_col(width = 0.6, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", rmse)),
    hjust = -0.1, size = 3
  ) +
  scale_fill_manual(values = landcover_colors) +
  coord_flip() +
  geom_hline(yintercept = 0, color = "grey50", linetype = "dashed") +
  labs(x = NULL, y = "RMSE [°C]") +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15))
  )

# Display the plots
p_landcover_corr

# Save as PNG
# ggsave("../plots_report/landcover_rmse_2023-07-09_14-00.png", p_landcover_corr, width = 10, height = 5, dpi = 300)
```

--------------------------------------------------------------------------------

Comparison of the monthly mean temperature surface with the 
RK temperature prediction surface for hourly means

```{r Temporal variability analysis per pixel}

# Load monthly mean RK surface
mm_july_rk  <- terra::rast("../Monthly_ANBH_RK_2023/rk_predictions/2023-07-01_0000_rk_prediction.tif")

# Directory with hourly RK predictions for July 2023
rk_dir <- "../RK_all_07_2023/rk_predictions"
rk_files <- list.files(rk_dir, pattern = "2023-07.*_rk_prediction\\.tif$", full.names = TRUE)

# Stack all hourly rasters
rk_stack <- rast(rk_files)

# Pixel-wise mean temperature as hourly average over July
rk_mean_july <- app(rk_stack, fun = mean, na.rm = TRUE)

# Pixel-wise SD to assess temporal variability
rk_sd_july <- app(rk_stack, fun = sd, na.rm = TRUE)

# Coefficient of variation to show relative variability
rk_cv_july <- rk_sd_july / rk_mean_july

# Difference Map
diff_month_hourly <- rk_mean_july - mm_july_rk
```

```{r}
# Clip/mask to study area
diff_month_hourly_clip <- terra::mask(diff_month_hourly, hd_bounds)

# Convert raster to data frame for ggplot
diff_df <- as.data.frame(diff_month_hourly_clip, xy = TRUE, na.rm = TRUE)
names(diff_df)[3] <- "delta_temp"

# Plot difference map
diff_map <- ggplot(diff_df, aes(x = x, y = y, fill = delta_temp)) +
  geom_raster() +
  coord_equal(expand = FALSE) +
  scale_fill_gradient2(
    name = expression(Delta~"T [°C]"),
    midpoint = 0,
    breaks = scales::pretty_breaks(n = 5)
  ) +
  annotation_scale(location = "br", width_hint = 0.3) +
  annotation_north_arrow(
    location = "tl", which_north = "true",
    width = unit(0.9, "cm"),
    style = north_arrow_orienteering
  ) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text  = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold")
  )

diff_map

# Save as PNG
# ggsave("../plots_report/diff_map_monthly_hourly.png", 
#        diff_map, width = 8, height = 5, dpi = 300)
```

```{r Residual variability relative to the monthly mean RK}

# Compute residuals as hourly RK minus monthly mean RK
res_stack <- rk_stack - mm_july_rk

# Pixel-wise SD of residuals (temporal variability)
res_var <- app(res_stack, fun = sd, na.rm = TRUE)

# Clip data before plotting
res_var <- terra::mask(res_var, hd_bounds)

# Convert to data frame for plotting
res_df <- as.data.frame(res_var, xy = TRUE, na.rm = TRUE)
names(res_df)[3] <- "residual_sd"

# Plot spatial SD map
resid_var <- ggplot(res_df, aes(x = x, y = y, fill = residual_sd)) +
  geom_raster() +
  scale_fill_viridis_c(name = "Residual\nSD [°C]", option = "viridis",
                       direction = 1) +
  annotation_scale(location = "br", width_hint = 0.3) +
  annotation_north_arrow(location = "tl", which_north = "true", 
                         width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.text  = element_blank(),
    axis.ticks = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )

resid_var

# Save as PNG
# ggsave("../plots_report/residual_var_relative.png", resid_var, width = 8, height = 5, dpi = 300)
```

```{r Mean SD per landcover class hourly vs. monthly}

# Extract mean SD per landcover polygon
res_var_by_lc <- terra::extract(res_var, landuse, fun = mean, na.rm = TRUE)

# Rename value column
names(res_var_by_lc)[2] <- "mean_sd"

# Add landcover class names
res_var_by_lc$hd_osm_landuse_4326 <- landuse$hd_osm_landuse_4326

# Aggregate by class
res_var_summary <- res_var_by_lc %>%
  group_by(hd_osm_landuse_4326) %>%
  summarise(mean_sd = mean(mean_sd, na.rm = TRUE)) %>%
  arrange(desc(mean_sd))

# Map numeric land-cover codes to descriptive class labels
res_var_summary <- res_var_summary %>%
  dplyr::mutate(lu_label = lu_lookup[as.character(hd_osm_landuse_4326)])

# Ensure labels exist + drop NAs
plot_df <- res_var_summary %>%
  filter(!is.na(lu_label), !is.na(mean_sd)) %>%
  mutate(lu_label = as.character(lu_label))

# Order classes by mean SD
plot_df <- plot_df %>%
  arrange(mean_sd) %>%
  mutate(lu_label = factor(lu_label, levels = lu_label))

# Overall mean (reference)
overall_mean <- mean(plot_df$mean_sd, na.rm = TRUE)

# Tight x-axis limits (adds a small padding)
rng <- range(plot_df$mean_sd, na.rm = TRUE)
pad <- diff(rng) * 0.15
xlim_tight <- c(rng[1] - pad, rng[2] + pad)

sd_dotplot <- ggplot(plot_df, aes(x = mean_sd, y = lu_label)) +
  geom_vline(xintercept = overall_mean, linetype = "dashed", linewidth = 0.6, alpha = 0.35) +
  geom_point(aes(color = lu_label), size = 2.8) +
  geom_text(aes(label = sprintf("%.2f", mean_sd)), color = "black", hjust = 0,
            nudge_x = 0.006, size = 3, show.legend = FALSE) +
  scale_color_manual(values = landcover_colors, guide = "none") +
  scale_x_continuous(limits = xlim_tight, breaks = scales::pretty_breaks(n = 5),
                     expand = expansion(mult = c(0, 0.06))) +
  labs(x = "Mean SD [°C]", y = NULL) +
  theme_bw(base_size = 13) +
  theme(
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank(),
    axis.title.x = element_text(margin = margin(t = 15))
  )

sd_dotplot

# Save the plot
# ggsave("../plots_report/residual_var_relative_per_landcover_dotplot.png", sd_dotplot, width = 10, height = 5, dpi = 300)
```
