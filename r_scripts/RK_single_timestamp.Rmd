---
title: "RK_single_timestamp"
author: "Johannes Gruenewald"
date: "2025-06-25"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load Required Libraries

# Spatial Data Handling & Processing
library(sf)
library(sp)
library(terra)
library(raster)
library(stars)
library(spdep)

# Spatial Analysis & Interpolation
library(gstat)
library(randomForest)
library(nlme)
library(automap)
library(mgcv)

# Data Manipulation & Wrangling
library(tidyverse)

# Data Visualization
library(ggplot2)
library(scales)
library(gridExtra)

# Mapping & Interactive Visualization
library(tmap)

# Additional
library(lattice)
```

------------------------------------------------------------------------

```{r}
# Load and preprocess temp data

# Read temperature data
temp <- sf::read_sf('../data/temp_HD/sensor_data_20230107_31days.gpkg')

# Removes rows where temp is NA
temp <- temp[!is.na(temp$temperature), ] 

# Reproject the data for Germany
temp <- st_transform(temp, crs="EPSG:32632")

# Ensure dateobserved is in the correct date-time format with German timezone
temp <- temp %>%
  mutate(dateobserved = as.POSIXct(dateobserved, format="%Y-%m-%d %H:%M:%S", tz = "Europe/Berlin"))

# Calculate hour count since epoch, rounded down to current hour
temp$chour <- floor(as.numeric(temp$dateobserved) / 3600)

# Test the results
print(format(as.POSIXct(temp$chour[66163] * 3600, origin = "1970-01-01", tz = "Europe/Berlin"), "%Y-%m-%d %H:%M:%S %Z"))
```

------------------------------------------------------------------------

```{r}
# Calculate hourly means for each unique stations for the month of July

# Calculate mean temperature for each station and hour during July
temp_hm <- temp %>%
  filter(format(dateobserved, "%m") == "07") %>%  # Keep only July data
  group_by(stationname, chour) %>%                # Group by station and hour
  summarise(mh_temp = mean(temperature, na.rm = TRUE), .groups = "drop") %>%
  mutate(hour = as.POSIXct(chour * 3600, origin = "1970-01-01", tz = "Europe/Berlin"))
```

```{r}
# Select one specific hourly mean for all the measurement stations

# Select, for each station, the record at its latest hour
sel_temp_hm <- temp_hm %>%
  group_by(stationname) %>%
  slice_max(order_by = chour, n = 1, with_ties = FALSE) %>%
  ungroup()

# Plot selected data
plot(sel_temp_hm$mh_temp,
     pch = 21,                     
     col = "black",              
     bg = "grey",               
     cex = 1.4,               
     main = paste("Hourly Mean Temperature at 31 Stations\n( Timestamp:", unique(sel_temp_hm$hour),")"),
     xlab = "Station Index",
     ylab = "Mean Temperature (°C)",
     ylim = range(sel_temp_hm$mh_temp) + c(-0.5, 0.5),
     las = 1,                     
     bty = "l"                     
)
grid()
```

------------------------------------------------------------------------

Extract coordinates of the measurement stations

```{r}
# Extract coordinates of the measurement stations
# maybe use them as covariates

# Extract coordinates and data into a data frame
coords <- st_coordinates(temp)
locs <- cbind(temp, coords)
locs <- as.data.frame(locs)

# Keep only one row per station and select relevant columns
station_coords <- locs %>%
  distinct(stationname, .keep_all = TRUE) %>%
  select(stationname, X, Y)

# Inspect the structure
str(station_coords)
```

------------------------------------------------------------------------

Load and process environmental covariates

```{r}
# Load the elevation data
dem <- terra::rast("../data/DEM/hd_elevation_4326.tif")

# Reproject the elevation data to match correct CRS
dem <- terra::project(dem, y = crs(temp))
```

```{r}
# Load the elevation data
tch <- terra::rast("../data/Canopy_height/clip_Forest_height_2019_NAFR.tif")

# Mask out all values which are assigned to water and have value 101
# Not part of this area. But needs to be masked as well: 102 Snow/ice; 103 No data
tch[tch == 101] <- NA

# Reproject the elevation data to match correct CRS
tch <- terra::project(tch, y = crs(temp))

# Check if the two covariates have the same crs
crs(tch) == crs(dem)
```

```{r}
# Load the elevation data
ghs_bh <- terra::rast("../data/building_height/clip_GHS_BUILT_H_AGBH_E2018_GLOBE_R2023A_54009_100_V1_0_R4_C19.tif")

# Reproject the elevation data to match correct CRS
ghs_bh <- terra::project(ghs_bh, y = crs(temp))

# Check if CRS is correct
crs(ghs_bh) == crs(dem)
```

------------------------------------------------------------------------

```{r}
# Create a Raster Stack for all the covariate information

# Check resolution of each raster
terra::res(dem)
terra::res(tch)
terra::res(ghs_bh)

# Align TCH and building height to DEM resolution and extent
tch_aligned    <- terra::resample(tch, dem, method = "bilinear")
ghs_bh_aligned <- terra::resample(ghs_bh, dem, method = "near")

# Stack all layers
env_stack <- c(dem, tch_aligned, ghs_bh_aligned)

# Rename layers for clarity
names(env_stack) <- c("elev", "canopy", "bldg")

env_stack
```

```{r}
# Also add lat and lon to the raster stack

# Create coordinate rasters
lon <- terra::xFromCell(env_stack, 1:ncell(env_stack))
lat <- terra::yFromCell(env_stack, 1:ncell(env_stack))

# Convert to raster layers
lon_raster <- dem
lat_raster <- dem
values(lon_raster) <- lon
values(lat_raster) <- lat
names(lon_raster) <- "lon"
names(lat_raster) <- "lat"
```

```{r}
# Stack the three raster layers
grids <- c(env_stack, lon_raster, lat_raster)

grids
```

------------------------------------------------------------------------

```{r}
# Add proximity to water as another covariate

# Convert grid data to point features
points_vect <- as.points(grids)

# Convert point vector to sf object for spatial analysis
grid_sf <- st_as_sf(points_vect)

# Load river network
neckar <- st_read("../data/waterways/waterways_HD.gpkg")

# Reproject to 32632
neckar <- st_transform(neckar, crs = st_crs(temp))

# Clip Neckar river to extent of the grid (AOI)
neckar_clipped <- st_intersection(neckar, st_as_sfc(st_bbox(grid_sf)))

# Calculate minimum distance from each grid point to the Neckar river
grid_sf$dwater <- st_distance(grid_sf, neckar_clipped) %>%
  apply(1, min) %>%
  as.numeric()

# Cap at 500 meters to limit influence of distant points
#grid_sf$dwater[grid_sf$dwater > 500] <- NA

# Move 'dist_to_neckar' to first column
grid_sf <- grid_sf[, c("dwater", setdiff(names(grid_sf), "dwater"))]
```

------------------------------------------------------------------------

```{r}
# Convert to SpatialPointsDataFrame
grids_sp <- as(grid_sf, "Spatial")

# Now to SpatialPixelsDataFrame
gridded(grids_sp) <- TRUE

# Convert to SpatialGridDataFrame
grids_sp <- as(grids_sp, "SpatialGridDataFrame")

str(grids_sp)
```

```{r}
# Plot all the covariates before proceeding with regression and kriging

grid.arrange(
  spplot(grids_sp["dwater"],  
         main = "Proximity to Water [m]",  
         col.regions = terrain.colors(100)),
  spplot(grids_sp["elev"],    
         main = "Elevation [m]",           
         col.regions = viridis::viridis(100)),
  spplot(grids_sp["canopy"],  
         main = "Tree Canopy Height [m]",  
         col.regions = hcl.colors(100, "YlGn")),
  spplot(grids_sp["bldg"],    
         main = "Building Height [m]",     
         col.regions = heat.colors(100)),
  ncol = 2
)
```

------------------------------------------------------------------------

```{r}
# Adding covariates to temperature data

# Convert Spatial object to a RasterBrick
r_brick <- brick(grids_sp)

# Convert the RasterBrick to a terra SpatRaster object
grid_terra <- rast(r_brick)

# Extract raster values at the point locations
extracted_vals <- terra::extract(grid_terra, sel_temp_hm)

# Remove the first column (ID)
extracted_vals <- extracted_vals[,-1]

# Combine the point data with the extracted raster values
temp_shm.ex <- cbind(as.data.frame(sel_temp_hm), extracted_vals)

str(temp_shm.ex)
```

------------------------------------------------------------------------

Test RK with linear regression model as a test run

Other potential covariates: - daily variation of temperature. How can
this be modeled? - Sometimes windspeed also has values. As a temporal
variable? Or should it be based on constant data to ensure
transferbility - Proximity to water -\> implemented but unsure what the
best solution would be for this covariate. Until a certain distance? Or
what would make sense?

```{r}
# Fit a linear model predicting mean hourly temperature
# using elevation, canopy height, and building height as predictors
lm.temp_shm <- lm(mh_temp ~ dwater + elev + canopy + bldg, data = temp_shm.ex)

# Show a summary of the fitted model (coefficients, R², p-values, etc.)
summary(lm.temp_shm)

# Save the model's residuals back into original df as new column
temp_shm.ex$residuals <- lm.temp_shm$residuals

# Inspect the structure of the updated data frame
str(temp_shm.ex)

# Convert the data frame into an 'sf' spatial object using the existing geometry
temp_shm.sf <- st_as_sf(temp_shm.ex)

# Confirm the resulting object's class
str(temp_shm.sf)
```

------------------------------------------------------------------------

Anisotropy

```{r}
# Compute a directional variogram map of the model residuals
# Helps to reveal spatial structure (anisotropy) not explained by the model

varmap <- variogram(residuals ~ 1, data = temp_shm.sf, map = TRUE,
                    # cutoff is half the spatial extent (or diameter) of the study area
                    cutoff = sqrt(areaSpatialGrid(grids_sp)) / 2, 
                    # scaled relative to the resolution of the grid
                    width = 30 * grids_sp@grid@cellsize[1])

cutoff_val <- sqrt(areaSpatialGrid(grids_sp)) / 2
width_val  <- 30 * grids_sp@grid@cellsize[1]

# Plot the computed variogram map
plot(varmap,
     col.regions = grey(rev(seq(0, 1, 0.025))),
     main = sprintf("Directional Variogram Map (cutoff: %.1f km, width: %.1f km)", 
                    cutoff_val / 1000, width_val / 1000))

# Compute directional variograms for North–South (0°) and East–West (90°)
rv.temp <- variogram(residuals ~ 1, temp_shm.sf, alpha=c(0,90))


rvgm.temp <- fit.variogram(rv.temp,
    vgm(psill=var(temp_shm.sf$residuals),
        "Exp", nugget=0, anis= c(p=90, s=0.5))) # p = direction, s = anisotropy ratio

# Plot the empirical and fitted directional variograms
plot(rv.temp, rvgm.temp,
     main = "Directional Variogram Fit (0° vs 90°)",
     plot.nu=FALSE, cex=2, pch="+", col="black")
```

Could the anisotropy which can be visualy identified in the E-W
direction be caused by the Neckar? Residuals are more dissimilar in this
direction indicating higher semivariance -\> more difference between
residuals

-   Anisotropy is present -\> Spatial correlation varies by direction
-   Stronger continuity in N–S -\> Lower semivariance at 0° -\> Data is
    more predictable N–S
-   Weaker continuity in E–W -\> Higher semivariance at 90° -\> Greater
    variation E–W (anisotropy) Model fit Reasonable in both panels which
    is a good basis for kriging

------------------------------------------------------------------------

Defining the geostatistical model for residuals

```{r}
g.resid <- gstat(
  id = c("residuals"),
  formula = residuals ~ 1,
  data = temp_shm.sf,
  nmax = 31,
  model = rvgm.temp
)
```

------------------------------------------------------------------------

Leave-One-Out Cross Validation applied to ordinary kriging residual
model

```{r}
# Cross-validation of the kriging model
cv_resid <- krige.cv(residuals ~ 1,
                     locations = temp_shm.sf,
                     model = rvgm.temp,
                     nfold = nrow(temp_shm.sf),       # or nrow(temp_shm.sf) for LOOCV
                     nmax = 10)

# Metrics
cv_rmse <- sqrt(mean(cv_resid$residual^2))
cv_mae  <- mean(abs(cv_resid$residual))
cv_me   <- mean(cv_resid$residual)

cat("Cross-Validation RMSE:", round(cv_rmse, 2), "\n")
cat("Cross-Validation MAE :", round(cv_mae, 2), "\n")
cat("Cross-Validation Bias:", round(cv_me, 2), "\n")

ggplot(cv_resid, aes(x = var1.pred, y = residual)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "Cross-validation residuals", x = "Predicted", y = "Residual")
```

Notes to CV plot: - if they are scattered fairly symmetrically around
zero -\> No strong pattern in residuals - indicates no obvious bias in
the predictions across the range. - the residuals do not fan out, so
homoscedasticity (constant variance) seems reasonable.

-   Slight underestimation bias if more residuals lie above the dotted
    line above the dotted line for negative predicted values, and below
    it for positive ones.
    -   This could suggest a mild S-shape, hinting at potential
        nonlinearity or slight model misspecification (though it's weak
        here).
-   No extreme outliers, but a few residuals fall close to ±0.5°C.

------------------------------------------------------------------------

Spatial Cross-Validation

THIS APPROACH DIDNT WORK SO FAR

```{r}
# Step 1: Generate spatial cross-validation folds
set.seed(42)
cv_folds <- spatialBlock(
  speciesData = temp_shm.sf,
  theRange = 500,        # Adjust based on spatial range
  k = 2,                  # 5-fold spatial CV
  selection = "random",
  iteration = 100,
  verbose = FALSE,
  showBlocks = FALSE
)

sapply(cv_folds$folds, length)


# Step 2: Initialize results container
cv_results <- data.frame(obs = numeric(), pred = numeric())

# Step 3: Loop over spatial folds
for (i in 1:cv_folds$k) {
  test_idx  <- unlist(cv_folds$folds[[i]])
  train_idx <- setdiff(1:nrow(temp_shm.sf), test_idx)
  
  train <- temp_shm.sf[train_idx, ]
  test  <- temp_shm.sf[test_idx, ]
  
  # Fit regression model
  lm_model <- lm(mh_temp ~ elev + canopy + bldg, data = train)
  test$lm_pred <- predict(lm_model, newdata = test)
  
  # Fit variogram on residuals
  train$residuals <- resid(lm_model)
  vgm_emp <- variogram(residuals ~ 1, data = train)
  vgm_fit <- fit.variogram(vgm_emp, vgm("Exp"))
  
  # Kriging of residuals
  g_resid <- gstat(id = "residuals", formula = residuals ~ 1,
                   data = train, model = vgm_fit, nmax = 40)
  krig <- predict(g_resid, newdata = test, BLUE = FALSE)
  
  # Final RK prediction
  rk_pred <- test$lm_pred + krig$residuals.pred
  
  # Store CV results
  cv_results <- rbind(cv_results,
                      data.frame(obs = test$mh_temp,
                                 pred = rk_pred))
}

# Step 4: Compute performance metrics
cv_rmse <- sqrt(mean((cv_results$obs - cv_results$pred)^2))
cv_mae  <- mean(abs(cv_results$obs - cv_results$pred))
cv_me   <- mean(cv_results$obs - cv_results$pred)

# Step 5: Print results
cat("Spatial CV RMSE:", round(cv_rmse, 2), "\n")
cat("Spatial CV MAE :", round(cv_mae, 2), "\n")
cat("Spatial CV Bias:", round(cv_me, 2), "\n")
```

------------------------------------------------------------------------

```{r}
# Predict the temperature trend component using the regression model
locTEMP.reg <- predict(lm.temp_shm, grids_sp)

# OK of the regression residuals to model spatial autocorrelation
locTEMP <- predict(g.resid, grids_sp, beta=1, BLUE=FALSE)

# Combine the regression prediction with kriged residuals to get final RK predictions
rk.pred <- locTEMP.reg + locTEMP$residuals.pred

# Add the RK predictions as a new variable to the spatial grid object
grids_sp$rk_pred <- rk.pred

# Convert station coordinates to a SpatialPoints object
coordinates(station_coords) <- ~ X + Y
proj4string(station_coords) <- CRS(proj4string(grids_sp))

# Plot RK results overlayed with stations
spplot(grids_sp, "rk_pred", main = "Regression Kriging Prediction (°C)",
       sp.layout = list("sp.points", station_coords, pch = 20, col = "white"))
```

Performance of final RK results

```{r}
# Extract predicted values from the RK surface at station coordinates
rk_at_stations <- sp::over(station_coords, grids_sp)

# Add observed values to the extracted predictions
rk_eval <- cbind(rk_at_stations, obs = temp_shm.sf$mh_temp)

# Calculate prediction error
rk_eval$residual <- rk_eval$obs - rk_eval$rk_pred

# Metrics
rmse <- sqrt(mean(rk_eval$residual^2, na.rm = TRUE))
mae  <- mean(abs(rk_eval$residual), na.rm = TRUE)
bias <- mean(rk_eval$residual, na.rm = TRUE)

cat("RK RMSE :", round(rmse, 2), "\n")
cat("RK MAE  :", round(mae, 2), "\n")
cat("RK Bias :", round(bias, 2), "\n")

ggplot(rk_eval, aes(x = rk_pred, y = residual)) +
  geom_point() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(title = "RK Prediction Residuals at Stations",
       x = "RK Predicted (°C)", y = "Residual (Observed - Predicted)")
```

Comments: - The residuals are centered around 0 across most of the
prediction range, confirming low bias overall. - No extreme outliers
that would suggest a completely failed prediction at any station.

-   At lower predicted temperatures (\< 16.5°C), residuals are mostly
    positive, meaning the model underestimates temperatures -\> cold
    areas are consistently predicted too cold.
-   At higher predicted values (\> 17.5°C), the model tends to slightly
    overestimate (negative residuals).
-   The spread of residuals seems to change across the predicted range.
    This could hint that the model errors are not uniform, especially
    for low-temperature areas.
