---
title: "RK_model_validation"
output: html_document
date: "2025-12-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load Required Libraries

# Spatial Data Handling & Processing
library(sf)
library(sp)
library(terra)
library(raster)
library(stars)
library(spdep)

# Spatial Analysis & Interpolation
library(gstat)
library(randomForest)
library(nlme)
library(automap)
library(mgcv)

# Data Manipulation & Wrangling
library(tidyverse)

# Data Visualization
library(ggplot2)
library(ggspatial)
library(scales)
library(gridExtra)
library(corrplot)

# Mapping & Interactive Visualization
library(tmap)

# Additional
library(lattice)
library(car)
```

Comparison of the Urban Climate Analysis of HD (2023) with the 
RK temperature prediction surface

```{r Prepare OSM LULC}

# Read OSM LULC raster
osm_lulc  <- rast("../data/OSM_LULC/hd_osm_landuse_4326.tif")

# Assign class labels
lulc_classes <- data.frame(
  value = c(
    5,   # Water bodies
    11,  # Urban fabric
    12,  # Industrial, commercial and transport units
    13,  # Mine, dump and construction sites
    14,  # Artificial, non-agricultural vegetated areas
    21,  # Arable land
    22,  # Permanent crops
    23,  # Pastures
    31,  # Forests
    32,  # Shrub and/or herbaceous vegetation associations
    33,  # Open spaces with little or no vegetation
    41   # Wetlands
  ),
  class_name = c(
    "Water bodies",
    "Urban fabric",
    "Industrial, commercial and transport units",
    "Mine, dump and construction sites",
    "Artificial, non-agricultural vegetated areas",
    "Arable land",
    "Permanent crops",
    "Pastures",
    "Forests",
    "Shrub and/or herbaceous vegetation associations",
    "Open spaces with little or no vegetation",
    "Wetlands"
  )
)

# Convert to polygon
lulc_polygons <- as.polygons(osm_lulc, dissolve = TRUE)

# Save output as geopackage
writeVector(lulc_polygons, "../data/OSM_LULC/hd_osm_lulc_polygons.gpkg", overwrite = TRUE)
```

```{r Compare the Stadtklima-Analyse with my RK prediction surface}

# Load rasters and vector data
mod  <- rast("../RK_07_2023_12days/rk_predictions/2023-07-09_1400_rk_prediction.tif")
ref5 <- rast("../data/stadtklimaanalyse_2023/2_22_074_ist_t14_rev01.tif")
river <- st_read("../data/waterways/waterways_HD.gpkg")                 
landuse <- st_read("../data/OSM_LULC/hd_osm_lulc_polygons.gpkg")
osm_lulc <- rast("../data/OSM_LULC/hd_osm_landuse_4326.tif")
hd_bounds <- sf::read_sf('../data/AOI/OSM_boundaries_HD.geojson')

# Check if model has CRS
if (is.na(crs(mod))) stop("`mod` has no CRS. Set it first.")

# Define CRS and project reference raster to model grid
crs_mod <- crs(mod, proj = TRUE)
crs(ref5) <- "EPSG:32632"
ref30 <- project(ref5, mod, method = "bilinear")
osm_lulc <- project(osm_lulc, mod, method = "near")

# Reproject vector layers to project CRS
hd_bounds <- st_transform(hd_bounds, crs = "EPSG: 32632")
crs_mod <- crs(mod, proj = TRUE)
river     <- st_transform(river,     crs = crs_mod)
landuse   <- st_transform(landuse,   crs = crs_mod)

# Crop and mask rasters by AOI
mod    <- mask(crop(mod,    vect(hd_bounds)), vect(hd_bounds))
ref30  <- mask(crop(ref30,  vect(hd_bounds)), vect(hd_bounds))
osm_lulc <- mask(crop(osm_lulc,  vect(hd_bounds)), vect(hd_bounds))

# Clip vector layers to AOI
river <- st_intersection(river, hd_bounds)
landuse <- st_intersection(landuse, hd_bounds)

# Verify alignment between datasets
stopifnot(terra::same.crs(ref30, mod))
print(st_crs(hd_bounds)$input)
stopifnot(isTRUE(all.equal(res(mod),  res(ref30))))
stopifnot(isTRUE(all.equal(ext(mod),  ext(ref30))))
stopifnot(isTRUE(all.equal(res(mod),  res(osm_lulc))))
stopifnot(isTRUE(all.equal(ext(mod),  ext(osm_lulc))))
```

```{r Model–Reference Temperature Comparison and Metrics}

# Select single-hour rasters
mod_h   <- mod    
ref30_h <- ref30       

# Apply common NA mask
both_mask <- !is.na(values(mod_h)) & !is.na(values(ref30_h))
mod_h[!both_mask]   <- NA
ref30_h[!both_mask] <- NA

# Extract cell values from both rasters
vr <- values(c(mod_h, ref30_h, osm_lulc))
colnames(vr) <- c("rk_temp", "ref_temp", "lu")
comparison_df <- as.data.frame(vr) |> drop_na()

# Calculate comparison metrics
pearson_r <- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "pearson")
spearman_r<- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "spearman")
bias_C    <- mean(comparison_df$rk_temp - comparison_df$ref_temp)
mae_C     <- mean(abs(comparison_df$rk_temp - comparison_df$ref_temp))
rmse_C    <- sqrt(mean((comparison_df$rk_temp - comparison_df$ref_temp)^2))

# Combine metrics for output
metrics <- c(
  pearson_r = pearson_r,
  spearman_r = spearman_r,
  bias_C = bias_C,
  MAE_C = mae_C,
  RMSE_C = rmse_C
)
print(metrics)

# Sample data if very large (for faster plotting)
set.seed(1)
comparison_plot_df <- if (nrow(comparison_df) > 1e6) {
  comparison_df[sample.int(nrow(comparison_df), 1e6), ]
} else comparison_df

# Plot model vs. reference scatter with 1:1 line
ggplot(comparison_plot_df, aes(x = ref_temp, y = rk_temp)) +
  geom_hex(bins = 40) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  coord_equal() +
  labs(
    x = "Reference (5 m downsampled to 30 m mean) [°C]",
    y = "RK model (30 m) [°C]",
    title = sprintf("Agreement at 14:00 — r = %.2f, RMSE = %.2f °C", pearson_r, rmse_C)
  )
```



Short interpretation of the plot:
The RK model reproduces the relative spatial pattern of heat well (r ≈ 0.88) but is systematically too warm by about 8–9 °C across the city at 14:00.

```{r RK and Reference Temperature Map Visualization}

# Convert rasters to data frames for plotting  
mod_df  <- as.data.frame(mod_h,  xy = TRUE, na.rm = TRUE)
ref_df  <- as.data.frame(ref30_h, xy = TRUE, na.rm = TRUE)
names(mod_df)[3] <- "value"
names(ref_df)[3] <- "value"

# Compute shared color scale range  
mm_mod <- terra::minmax(mod_h)
mm_ref <- terra::minmax(ref30_h)
rng <- range(c(mm_mod, mm_ref), na.rm = TRUE)

# Convert vector layers to sf  
river_sf     <- st_as_sf(river)
hd_bounds_sf <- st_as_sf(hd_bounds)

# Plot RK model map  
p_rk_map <- ggplot() +
  geom_raster(data = mod_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "Temperature [°C]", limits = rng) +
  coord_sf() + 
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
      subtitle = sprintf("Timestamp: 2023-07-09 14:00\nTemperature value range: %.1f – %.1f °C", 
                         min(mod_df$value, na.rm = TRUE), max(mod_df$value, na.rm = TRUE))) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, face = "plain", 
                                 margin = margin(t = 1, b = 5))
  )

# Plot reference map  
p_ref_map <- ggplot() +
  geom_raster(data = ref_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "PET [°C]", limits = rng) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
       subtitle = sprintf("Physiologically Equivalent Temperature (PET) value range: %.1f – %.1f °C", 
                          min(ref_df$value, na.rm = TRUE), max(ref_df$value, na.rm = TRUE))) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, face = "plain", 
                                 margin = margin(t = 1, b = 5))
  )




# Combine both plots with shared legend
# p_rk_ref <- (p_rk_map + p_ref_map +
#                     plot_layout(guides = "collect") &
#                     theme(legend.position = "right")) +
#   plot_annotation(
#     title = "Comparison of RK and Reference Temperature Maps — Heidelberg, 09-07-2023 14:00",
#     theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5,
#         margin = margin(b = 10)))
#   )

# Display combined plot
p_ref_map
p_rk_map

# Save as PNG
ggsave("../plots_report/rk_14-00.png", p_rk_map, width = 10, height = 5, dpi = 300)

ggsave("../plots_report/urban_model_14-00.png", p_ref_map, width = 10, height = 5, dpi = 300)
```


Short explanation of the following chunk:
The following chunk is a quality-control checkpoint. It doesn’t change the analysis output, but it ensures that what I compare is valid (same units, same grid, no hidden bias).
Keep it as a safety check but might omit it from the final report.

```{r Residual diagnostics and consistency checks}

# Residual summary (model-reference)
resid <- comparison_df$rk_temp - comparison_df$ref_temp
summary(resid)
mean(resid)        # mean bias
median(resid)      # median bias
mean(resid < 0)    # share of negative residuals
mean(resid > 0)    # share of positive residuals

# Unit consistency check
summary(comparison_df$rk_temp)
summary(comparison_df$ref_temp)
# Values ~280–320 → Kelvin; ~10–45 → Celsius
# A ~273.15 offset would indicate mixed units

# Spatial alignment check (CRS, resolution, extent)
stopifnot(terra::same.crs(ref30, mod))
stopifnot(isTRUE(all.equal(terra::res(ref30),  terra::res(mod))))
stopifnot(isTRUE(all.equal(terra::ext(ref30),  terra::ext(mod))))
```


Short interpretation of the residual summary metrics:
The RK model systematically overestimates temperatures by about +8.7 °C across all grid cells, with no negative residuals. Both datasets are in °C and perfectly aligned spatially.

```{r Spatial Residual Map and Histogram}

# Residual histogram
p_resid_hist <- ggplot(data.frame(resid), aes(x = resid)) +
  geom_histogram(bins = 60, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth = 0.6) +
  labs(
    subtitle = sprintf("Mean bias = %.2f °C", mean(resid)),
    x = "Residuals (RK predictions − Urban Climate Analysis) [°C]",
    y = "Number of cells"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10, margin = margin(b = 5)),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(color = "grey85"),
    axis.title = element_text(face = "bold")
  )

# Recalculate spatial residuals (per grid cell) to retain geographic structure 
resid_raster <- mod_h - ref30_h

# Convert residual raster to data frame for ggplot visualization
resid_map_df <- as.data.frame(resid_raster, xy = TRUE, na.rm = TRUE)
names(resid_map_df)[3] <- "residual"

# Define symmetric color scale limits around zero
rmax <- ceiling(max(abs(terra::global(resid_raster, "min", na.rm = TRUE)$min),
                    abs(terra::global(resid_raster, "max", na.rm = TRUE)$max)))
# round to nearest multiple of 5 for clean legend breaks
rmax <- ceiling(rmax / 5) * 5  

# Plot spatial residual distribution
p_resid_map <- ggplot() +
  geom_raster(data = resid_map_df, aes(x = x, y = y, fill = residual)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.5) +
  scale_fill_gradient2(
    name = "Residuals (°C)",
    low = "#2166ac", mid = "white", high = "#b2182b",
    midpoint = 0,
    limits = c(-rmax, rmax),
    breaks = seq(-15, 15, 5),
    labels = seq(-15, 15, 5)
  ) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
    subtitle = "Blue: Model colder than reference | Red: Model warmer than reference"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, margin = margin(b = 8)),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 9),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  )

# Display the plots
p_resid_hist
p_resid_map

# Save as PNG
ggsave("../plots_report/residual_histogram_rk_vs_reference_2023-07-09_14-00.png", p_resid_hist, width = 10, height = 5, dpi = 300)

ggsave("../plots_report/residual_spatial_map_rk_vs_reference_2023-07-09_14-00.png", p_resid_map, width = 10, height = 5, dpi = 300)
```


```{r Robust Performance Metrics and Regression Fit}

# Robust central tendency
median_bias <- median(resid, na.rm = TRUE)

# Linear regression between reference and model temperatures
lm_rk_ref_temp <- lm(ref_temp ~ rk_temp, data = comparison_df)
summary(lm_rk_ref_temp)$coefficients 
summary(lm_rk_ref_temp)$r.squared    

# Print summary results
c(median_bias = median_bias, R2 = summary(lm_rk_ref_temp)$r.squared)
```


Short interpretation of the linear regression model results:
The analysis shows that the RK model reproduces the general spatial temperature pattern well (R² = 0.78) but consistently predicts higher absolute temperatures than the reference. With a median bias of about +8.7 °C (in this case the same as mean_bias) and a regression slope of 2.7, the results indicate that the RK model is overall too warm and exhibits a narrower temperature range, underrepresenting the spatial variability present in the reference data.

```{r Mean Temperature and Correlation by Landuse Class}

# Align raster CRS to land use polygons
mod_h   <- project(mod_h, landuse)
ref30_h <- project(ref30_h, landuse)

# Extract mean temperature per land use polygon
mod_vals <- terra::extract(mod_h, landuse, fun = mean, na.rm = TRUE)
ref_vals <- terra::extract(ref30_h, landuse, fun = mean, na.rm = TRUE)

# Add mean values to land use data
landuse$rk_mean  <- mod_vals[, 2]
landuse$ref_mean <- ref_vals[, 2]

# Calculate model–reference difference
landuse <- landuse %>%
  mutate(diff = rk_mean - ref_mean)

# Summarize by land use class
corr_by_class <- comparison_df |>
  group_by(lu) |>
  summarise(
    n = n(),
    pearson  = if (n >= 2) cor(rk_temp, ref_temp) else NA_real_,
    spearman = if (n >= 2) cor(rk_temp, ref_temp, method = "spearman") else NA_real_,
    bias     = mean(rk_temp - ref_temp),
    rmse     = sqrt(mean((rk_temp - ref_temp)^2))
  )
```


```{r Color Palette for CORINE Landcover}

# Define color palette for land cover classes based on OSM LULC
landcover_colors <- c(
  "Water bodies" = "#2daae1",

  "Urban fabric" = "#e6004d",
  "Industrial, commercial and transport units" = "#c04be6",
  "Mine, dump and construction sites" = "#8c2d8f",
  "Artificial, non-agricultural vegetated areas" = "#f1b6da",

  "Arable land" = "#ffffb2",
  "Permanent crops" = "#e68026",
  "Pastures" = "#d9ef8b",

  "Forests" = "#1a9850",
  "Shrub and/or herbaceous vegetation associations" = "#a6d96a",
  "Open spaces with little or no vegetation" = "#e0f3db",

  "Wetlands" = "#b2b2ff"
)

# Combination class number and name
lu_lookup <- c(
  "5"  = "Water bodies",

  "11" = "Urban fabric",
  "12" = "Industrial, commercial and transport units",
  "13" = "Mine, dump and construction sites",
  "14" = "Artificial, non-agricultural vegetated areas",

  "21" = "Arable land",
  "22" = "Permanent crops",
  "23" = "Pastures",

  "31" = "Forests",
  "32" = "Shrub and/or herbaceous vegetation associations",
  "33" = "Open spaces with little or no vegetation",

  "41" = "Wetlands"
)
```

```{r Correlation by land cover class}

# Add a factor column to your data
corr_by_class$lu_label <- factor(
  lu_lookup[as.character(corr_by_class$lu)],
  levels = names(landcover_colors)
)

corr_by_class <- corr_by_class %>%
  mutate(
    lu_label_n = paste0(lu_label, " (n = ", n, ")")
  )

# Plot correlation by land cover class
p_landcover_corr <- ggplot(
  corr_by_class,
  aes(
    x = reorder(lu_label_n, pearson),
    y = pearson,
    fill = lu_label
  )
) +
  geom_col(width = 0.6, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", pearson)),
    hjust = -0.1, size = 3
  ) +
  scale_fill_manual(values = landcover_colors) +
  coord_flip() +
  geom_hline(yintercept = 0, color = "grey50", linetype = "dashed") +
  labs(x = NULL, y = "Pearson Correlation (r)") +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  )

# Display the plots
p_landcover_corr

# Save as PNG
ggsave("../plots_report/landcover_correlation_2023-07-09_14-00.png", p_landcover_corr, width = 10, height = 5, dpi = 300)

# Plot correlation by land cover class
p_landcover_corr <- ggplot(
  corr_by_class,
  aes(
    x = reorder(lu_label_n, rmse),
    y = rmse,
    fill = lu_label
  )
) +
  geom_col(width = 0.6, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", rmse)),
    hjust = -0.1, size = 3
  ) +
  scale_fill_manual(values = landcover_colors) +
  coord_flip() +
  geom_hline(yintercept = 0, color = "grey50", linetype = "dashed") +
  labs(x = NULL, y = "RMSE [°C]") +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  )

# Display the plots
p_landcover_corr

# Save as PNG
ggsave("../plots_report/landcover_rmse_2023-07-09_14-00.png", p_landcover_corr, width = 10, height = 5, dpi = 300)
```

--------------------------------------------------------------------------------

Comparison of the monthly mean temperature surface with the 
RK temperature prediction surface for hourly means

```{r Temporal variability analysis per pixel}

# Load monthly mean RK surface
mm_july_rk  <- terra::rast("../Monthly_RK_2023/rk_predictions/2023-07-01_0000_rk_prediction.tif")

# Directory with hourly RK predictions
rk_dir <- "../RK_all_07_2023/rk_predictions"

# List all hourly RK raster files for July 2023
rk_files <- list.files(rk_dir, pattern = "2023-07.*_rk_prediction\\.tif$", full.names = TRUE)

# Stack all hourly rasters
rk_stack <- rast(rk_files)

# Pixel-wise mean temperature (hourly average over July)
rk_mean_july <- app(rk_stack, fun = mean, na.rm = TRUE)

# Pixel-wise SD (temporal variability)
rk_sd_july <- app(rk_stack, fun = sd, na.rm = TRUE)

# Coefficient of variation (relative variability)
rk_cv_july <- rk_sd_july / rk_mean_july

# # Plot Coefficient of variation map
# plot(rk_cv_july, col = viridis(20),
#      main = "Relative RK Temperature Variability (CV, July 2023)",
#      xlab = "", ylab = "")
# 
# # Compare monthly mean, hourly mean, and hourly SD
# plot(c(mm_july_rk, rk_mean_july, rk_sd_july),
#      col = viridis(20),
#      main = c("Monthly Mean RK (from monthly model)",
#               "Hourly Mean RK (average of all hours)",
#               "Hourly Variability (SD across hours)"))
```

```{r Plot temporal variability of hourly RK predictions}

# Clip data before plotting
rk_sd_july_clip <- terra::mask(rk_sd_july, hd_bounds)

# Convert raster to data frame
rk_sd_df <- as.data.frame(rk_sd_july_clip, xy = TRUE, na.rm = TRUE)
names(rk_sd_df)[3] <- "sd_temp"

# Plot Temporal variability of hourly RK predictions
# Standard deviation of hourly air temperature (July 2023)
temp_var <- ggplot(rk_sd_df, aes(x = x, y = y, fill = sd_temp)) +
  geom_raster() +
  coord_equal() +
  scale_fill_viridis_c(
    name = "Standard\nDeviation (°C)",
    option = "viridis",
    direction = 1
  ) +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )

temp_var

# Save as PNG
ggsave("../plots_report/temporal_sd_hourly_rk_predictions.png", temp_var, width = 10, height = 5, dpi = 300)
```

```{r Plot relative variability of hourly RK predictions}

# Clip data before plotting
rk_cv_july_clip <- terra::mask(rk_cv_july, hd_bounds)

# Convert raster to data frame
rk_cv_df <- as.data.frame(rk_cv_july_clip, xy = TRUE, na.rm = TRUE)
names(rk_cv_df)[3] <- "coeff_var"

# Plot relative variability of hourly RK predictions
# Coefficient of Variation of hourly air temperature (July 2023)
temp_coeff_var <- ggplot(rk_cv_df, aes(x = x, y = y, fill = coeff_var)) +
  geom_raster() +
  coord_equal() +
  scale_fill_viridis_c(
    name = "Coefficient of\nVariation",
    option = "viridis",
    direction = 1
  ) +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )

temp_coeff_var

# Save as PNG
ggsave("../plots_report/temporal_cv_hourly_rk_predictions.png", temp_var, width = 10, height = 5, dpi = 300)
```

```{r Residual variability relative to the monthly mean RK}

# Residuals = hourly RK minus monthly mean RK
res_stack <- rk_stack - mm_july_rk

# Pixel-wise SD of residuals (temporal variability)
res_var <- app(res_stack, fun = sd, na.rm = TRUE)

# Clip data before plotting
res_var <- terra::mask(res_var, hd_bounds)

# Convert to data frame for plotting
res_df <- as.data.frame(res_var, xy = TRUE, na.rm = TRUE)
names(res_df)[3] <- "residual_sd"

# Plot spatial SD map
resid_var <- ggplot(res_df, aes(x = x, y = y, fill = residual_sd)) +
  geom_raster() +
  coord_equal() +
  scale_fill_viridis_c(
    name = "Residual SD (°C)",
    option = "viridis",
    direction = 1
  ) +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(x = NULL, y = NULL) +
  theme_minimal(base_size = 13) +
  theme(
    panel.grid = element_blank(),
    legend.position = "right",
    plot.title = element_text(face = "bold")
  )

resid_var
```

```{r}
# Extract mean SD per landcover polygon
res_var_by_lc <- terra::extract(res_var, landuse, fun = mean, na.rm = TRUE)

# Rename value column
names(res_var_by_lc)[2] <- "mean_sd"

# Add landcover class names
res_var_by_lc$hd_osm_landuse_4326 <- landuse$hd_osm_landuse_4326

# Aggregate by class
res_var_summary <- res_var_by_lc %>%
  group_by(hd_osm_landuse_4326) %>%
  summarise(mean_sd = mean(mean_sd, na.rm = TRUE)) %>%
  arrange(desc(mean_sd))

res_var_summary <- res_var_summary %>%
  dplyr::mutate(
    lu_label = lu_lookup[as.character(hd_osm_landuse_4326)]
  )

res_var_summary <- res_var_summary %>%
  dplyr::mutate(
    lu_label = lu_lookup[as.character(hd_osm_landuse_4326)]
  )

# Plot Residual Variability by Landcover Class",
# Standard deviation of hourly RK from monthly RK mean residuals (July 2023)
ggplot(
  res_var_summary,
  aes(x = reorder(lu_label, mean_sd), y = mean_sd, fill = lu_label)) +
  geom_col(width = 0.6, color = "grey30") +
  geom_text(
    aes(label = sprintf("%.2f", mean_sd)),
    hjust = -0.1, size = 3
  ) +
  scale_fill_manual(values = landcover_colors) +
  coord_flip() +
  labs(
    x = NULL,
    y = "Mean SD (°C)"
  ) +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none",
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  )
```

