---
title: "RK_model_validation"
output: html_document
date: "2025-12-05"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load Required Libraries

# Spatial Data Handling & Processing
library(sf)
library(sp)
library(terra)
library(raster)
library(stars)
library(spdep)

# Spatial Analysis & Interpolation
library(gstat)
library(randomForest)
library(nlme)
library(automap)
library(mgcv)

# Data Manipulation & Wrangling
library(tidyverse)

# Data Visualization
library(ggplot2)
library(ggspatial)
library(scales)
library(gridExtra)
library(corrplot)

# Mapping & Interactive Visualization
library(tmap)

# Additional
library(lattice)
library(car)
```

Comparison of the Urban Climate Analysis of HD (2023) with the 
RK temperature prediction surface

```{r Prepare OSM LULC}

# Read OSM LULC raster
osm_lulc  <- rast("../data/OSM_LULC/hd_osm_landuse_4326.tif")

# Assign class labels
lulc_classes <- data.frame(
  value = c(
    5,   # Water bodies
    11,  # Urban fabric
    12,  # Industrial, commercial and transport units
    13,  # Mine, dump and construction sites
    14,  # Artificial, non-agricultural vegetated areas
    21,  # Arable land
    22,  # Permanent crops
    23,  # Pastures
    31,  # Forests
    32,  # Shrub and/or herbaceous vegetation associations
    33,  # Open spaces with little or no vegetation
    41   # Wetlands
  ),
  class_name = c(
    "Water bodies",
    "Urban fabric",
    "Industrial, commercial and transport units",
    "Mine, dump and construction sites",
    "Artificial, non-agricultural vegetated areas",
    "Arable land",
    "Permanent crops",
    "Pastures",
    "Forests",
    "Shrub and/or herbaceous vegetation associations",
    "Open spaces with little or no vegetation",
    "Wetlands"
  )
)

# Convert to polygon
lulc_polygons <- as.polygons(osm_lulc, dissolve = TRUE)

# Save output as geopackage
writeVector(lulc_polygons, "../data/OSM_LULC/hd_osm_lulc_polygons.gpkg", overwrite = TRUE)
```


```{r Compare the Stadtklima-Analyse with my RK prediction surface}

# Load rasters and vector data
mod  <- rast("../RK_07_2023_12days/rk_predictions/2023-07-09_1400_rk_prediction.tif")
ref5 <- rast("../data/stadtklimaanalyse_2023/2_22_074_ist_t14_rev01.tif")
river <- st_read("../data/waterways/waterways_HD.gpkg")                 
landuse <- st_read("../data/OSM_LULC/hd_osm_lulc_polygons.gpkg")

# Check if model has CRS
if (is.na(crs(mod))) stop("`mod` has no CRS. Set it first.")

# Define CRS and project reference raster to model grid
crs_mod <- crs(mod, proj = TRUE)
crs(ref5) <- "EPSG:32632"
ref30 <- project(ref5, mod, method = "bilinear")

# Reproject vector layers to project CRS
crs_mod <- crs(mod, proj = TRUE)
hd_bounds <- st_transform(hd_bounds, crs = crs_mod)
river     <- st_transform(river,     crs = crs_mod)
landuse   <- st_transform(landuse,   crs = crs_mod)

# Crop and mask rasters by AOI
mod    <- mask(crop(mod,    vect(hd_bounds)), vect(hd_bounds))
ref30  <- mask(crop(ref30,  vect(hd_bounds)), vect(hd_bounds))

# Clip vector layers to AOI
river <- st_intersection(river, hd_bounds)
landuse <- st_intersection(landuse, hd_bounds)

# Verify alignment between datasets
stopifnot(terra::same.crs(ref30, mod))
print(st_crs(hd_bounds)$input)
stopifnot(isTRUE(all.equal(res(mod),  res(ref30))))
stopifnot(isTRUE(all.equal(ext(mod),  ext(ref30))))
```

```{r Model–Reference Temperature Comparison and Metrics}

# Select single-hour rasters
mod_h   <- mod    
ref30_h <- ref30       

# Apply common NA mask
both_mask <- !is.na(values(mod_h)) & !is.na(values(ref30_h))
mod_h[!both_mask]   <- NA
ref30_h[!both_mask] <- NA

# Extract cell values from both rasters
vr <- values(c(mod_h, ref30_h))           
colnames(vr) <- c("rk_temp", "ref_temp")  # rename columns
comparison_df <- as.data.frame(vr) |> drop_na() 

# Calculate comparison metrics
pearson_r <- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "pearson")
spearman_r<- cor(comparison_df$rk_temp, comparison_df$ref_temp, method = "spearman")
bias_C    <- mean(comparison_df$rk_temp - comparison_df$ref_temp)
mae_C     <- mean(abs(comparison_df$rk_temp - comparison_df$ref_temp))
rmse_C    <- sqrt(mean((comparison_df$rk_temp - comparison_df$ref_temp)^2))

# Combine metrics for output
metrics <- c(
  pearson_r = pearson_r,
  spearman_r = spearman_r,
  bias_C = bias_C,
  MAE_C = mae_C,
  RMSE_C = rmse_C
)
print(metrics)

# Sample data if very large (for faster plotting)
set.seed(1)
comparison_plot_df <- if (nrow(comparison_df) > 1e6) {
  comparison_df[sample.int(nrow(comparison_df), 1e6), ]
} else comparison_df

# Plot model vs. reference scatter with 1:1 line
ggplot(comparison_plot_df, aes(x = ref_temp, y = rk_temp)) +
  geom_hex(bins = 40) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  coord_equal() +
  labs(
    x = "Reference (5 m downsampled to 30 m mean) [°C]",
    y = "RK model (30 m) [°C]",
    title = sprintf("Agreement at 14:00 — r = %.2f, RMSE = %.2f °C", pearson_r, rmse_C)
  )
```



Short interpretation of the plot:
The RK model reproduces the relative spatial pattern of heat well (r ≈ 0.88) but is systematically too warm by about 8–9 °C across the city at 14:00.

```{r RK and Reference Temperature Map Visualization}

# Convert rasters to data frames for plotting  
mod_df  <- as.data.frame(mod_h,  xy = TRUE, na.rm = TRUE)
ref_df  <- as.data.frame(ref30_h, xy = TRUE, na.rm = TRUE)
names(mod_df)[3] <- "value"
names(ref_df)[3] <- "value"

# Compute shared color scale range  
mm_mod <- terra::minmax(mod_h)
mm_ref <- terra::minmax(ref30_h)
rng <- range(c(mm_mod, mm_ref), na.rm = TRUE)

# Convert vector layers to sf  
river_sf     <- st_as_sf(river)
hd_bounds_sf <- st_as_sf(hd_bounds)

# Plot RK model map  
p_rk_map <- ggplot() +
  geom_raster(data = mod_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "Temperature [°C]", limits = rng) +
  coord_sf() + 
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
      subtitle = sprintf("Timestamp: 2023-07-09 14:00\nTemperature value range: %.1f – %.1f °C", 
                         min(mod_df$value, na.rm = TRUE), max(mod_df$value, na.rm = TRUE))) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, face = "plain", 
                                 margin = margin(t = 1, b = 5))
  )

# Plot reference map  
p_ref_map <- ggplot() +
  geom_raster(data = ref_df, aes(x = x, y = y, fill = value)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.4) +
  scale_fill_viridis_c(name = "PET [°C]", limits = rng) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
       subtitle = sprintf("Physiologically Equivalent Temperature (PET) value range: %.1f – %.1f °C", 
                          min(ref_df$value, na.rm = TRUE), max(ref_df$value, na.rm = TRUE))) +
  theme_minimal(base_size = 13) +
  theme(
    axis.title = element_blank(),
    axis.text  = element_blank(),
    panel.grid = element_blank(),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, face = "plain", 
                                 margin = margin(t = 1, b = 5))
  )




# Combine both plots with shared legend
# p_rk_ref <- (p_rk_map + p_ref_map +
#                     plot_layout(guides = "collect") &
#                     theme(legend.position = "right")) +
#   plot_annotation(
#     title = "Comparison of RK and Reference Temperature Maps — Heidelberg, 09-07-2023 14:00",
#     theme = theme(plot.title = element_text(size = 16, face = "bold", hjust = 0.5,
#         margin = margin(b = 10)))
#   )

# Display combined plot
p_ref_map
p_rk_map

# Save as PNG
ggsave("../plots_report/rk_14-00.png", p_rk_map, width = 10, height = 5, dpi = 300)

ggsave("../plots_report/urban_model_14-00.png", p_ref_map, width = 10, height = 5, dpi = 300)
```


Short explanation of the following chunk:
The following chunk is a quality-control checkpoint. It doesn’t change the analysis output, but it ensures that what I compare is valid (same units, same grid, no hidden bias).
Keep it as a safety check but might omit it from the final report.

```{r Residual diagnostics and consistency checks}

# Residual summary (model-reference)
resid <- comparison_df$rk_temp - comparison_df$ref_temp
summary(resid)
mean(resid)        # mean bias
median(resid)      # median bias
mean(resid < 0)    # share of negative residuals
mean(resid > 0)    # share of positive residuals

# Unit consistency check
summary(comparison_df$rk_temp)
summary(comparison_df$ref_temp)
# Values ~280–320 → Kelvin; ~10–45 → Celsius
# A ~273.15 offset would indicate mixed units

# Spatial alignment check (CRS, resolution, extent)
stopifnot(terra::same.crs(ref30, mod))
stopifnot(isTRUE(all.equal(terra::res(ref30),  terra::res(mod))))
stopifnot(isTRUE(all.equal(terra::ext(ref30),  terra::ext(mod))))
```


Short interpretation of the residual summary metrics:
The RK model systematically overestimates temperatures by about +8.7 °C across all grid cells, with no negative residuals. Both datasets are in °C and perfectly aligned spatially.

```{r Spatial Residual Map and Histogram}

# Residual histogram
p_resid_hist <- ggplot(data.frame(resid), aes(x = resid)) +
  geom_histogram(bins = 60, fill = "steelblue", color = "white", alpha = 0.8) +
  geom_vline(xintercept = 0, color = "black", linetype = "dashed", linewidth = 0.6) +
  labs(
    subtitle = sprintf("Mean bias = %.2f °C", mean(resid)),
    x = "Residuals (RK predictions − Urban Climate Analysis) [°C]",
    y = "Number of cells"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 10, margin = margin(b = 5)),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.major.y = element_line(color = "grey85"),
    axis.title = element_text(face = "bold")
  )

# Recalculate spatial residuals (per grid cell) to retain geographic structure 
resid_raster <- mod_h - ref30_h

# Convert residual raster to data frame for ggplot visualization
resid_map_df <- as.data.frame(resid_raster, xy = TRUE, na.rm = TRUE)
names(resid_map_df)[3] <- "residual"

# Define symmetric color scale limits around zero
rmax <- ceiling(max(abs(terra::global(resid_raster, "min", na.rm = TRUE)$min),
                    abs(terra::global(resid_raster, "max", na.rm = TRUE)$max)))
# round to nearest multiple of 5 for clean legend breaks
rmax <- ceiling(rmax / 5) * 5  

# Plot spatial residual distribution
p_resid_map <- ggplot() +
  geom_raster(data = resid_map_df, aes(x = x, y = y, fill = residual)) +
  geom_sf(data = river_sf, color = "lightblue", linewidth = 0.4) +
  geom_sf(data = hd_bounds_sf, fill = NA, color = "black", linewidth = 0.5) +
  scale_fill_gradient2(
    name = "Residuals (°C)",
    low = "#2166ac", mid = "white", high = "#b2182b",
    midpoint = 0,
    limits = c(-rmax, rmax),
    breaks = seq(-15, 15, 5),
    labels = seq(-15, 15, 5)
  ) +
  coord_sf() +
  annotation_scale(location = "br", width_hint = 0.3) +    
  annotation_north_arrow(location = "tl", which_north = "true", width = unit(0.9, "cm"),
                         style = north_arrow_orienteering) +
  labs(
    subtitle = "Blue: Model colder than reference | Red: Model warmer than reference"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    plot.subtitle = element_text(hjust = 0.5, size = 9, margin = margin(b = 8)),
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    legend.text = element_text(size = 9),
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank()
  )

# Display the plots
p_resid_hist
p_resid_map

# Save as PNG
ggsave("../plots_report/residual_histogram_rk_vs_reference_2023-07-09_14-00.png", p_resid_hist, width = 10, height = 5, dpi = 300)

ggsave("../plots_report/residual_spatial_map_rk_vs_reference_2023-07-09_14-00.png", p_resid_map, width = 10, height = 5, dpi = 300)
```


```{r Robust Performance Metrics and Regression Fit}

# Robust central tendency
median_bias <- median(resid, na.rm = TRUE)

# Linear regression between reference and model temperatures
lm_rk_ref_temp <- lm(ref_temp ~ rk_temp, data = comparison_df)
summary(lm_rk_ref_temp)$coefficients 
summary(lm_rk_ref_temp)$r.squared    

# Print summary results
c(median_bias = median_bias, R2 = summary(lm_rk_ref_temp)$r.squared)
```


Short interpretation of the linear regression model results:
The analysis shows that the RK model reproduces the general spatial temperature pattern well (R² = 0.78) but consistently predicts higher absolute temperatures than the reference. With a median bias of about +8.7 °C (in this case the same as mean_bias) and a regression slope of 2.7, the results indicate that the RK model is overall too warm and exhibits a narrower temperature range, underrepresenting the spatial variability present in the reference data.

```{r Mean Temperature and Correlation by Landuse Class}

# Align raster CRS to land use polygons
mod_h   <- project(mod_h, landuse)
ref30_h <- project(ref30_h, landuse)

# Extract mean temperature per land use polygon
mod_vals <- terra::extract(mod_h, landuse, fun = mean, na.rm = TRUE)
ref_vals <- terra::extract(ref30_h, landuse, fun = mean, na.rm = TRUE)

# Add mean values to land use data
landuse$rk_mean  <- mod_vals[, 2]
landuse$ref_mean <- ref_vals[, 2]

# Calculate model–reference difference
landuse <- landuse %>%
  mutate(diff = rk_mean - ref_mean)

# Summarize by land use class
landuse_summary <- landuse %>%
  st_drop_geometry() %>%
  group_by(class_2018) %>%
  summarise(
    rk_mean   = mean(rk_mean, na.rm = TRUE),
    ref_mean  = mean(ref_mean, na.rm = TRUE),
    diff_mean = mean(diff, na.rm = TRUE),
    corr      = cor(rk_mean, ref_mean, use = "complete.obs")
  )

print(landuse_summary)
```


```{r Color Palette for CORINE Landcover}

# Define color palette for land cover classes based on CORINE
landcover_colors <- c(
  "Continuous Urban fabric (S.L. > 80%)" = "#a40000",
  "Discontinuous Dense Urban Fabric (S.L.: 50% - 80%)" = "#d73027",
  "Discontinuous Medium Density Urban Fabric (S.L.: 30% - 50%)" = "#f46d43",
  "Discontinuous Low Density Urban Fabric (S.L.: 10% - 30%)" = "#fdae61",
  "Discontinuous very Low Density Urban Fabric (S.L.: < 10%)" = "#fee090",
  "Isolated Structures" = "#ffffbf",
  "Industrial, commercial, public, military and private units" = "#bdbdbd",
  "Fast transit roads and associated land" = "#969696",
  "Other roads and associated land" = "#636363",
  "Railways and associated land" = "#252525",
  "Port areas" = "#878787",
  "Airports" = "#cccccc",
  "Mineral extraction and dump sites" = "#ffcc99",
  "Construction sites" = "#ffeda0",
  "Land without current use" = "#f0f0f0",
  "Green urban areas" = "#78c679",
  "Sports and leisure facilities" = "#41ab5d",
  "Arable land (annual crops)" = "#e6ab02",
  "Permanent crops" = "#fee391",
  "Pastures" = "#a1d99b",
  "Complex and mixed cultivation patterns" = "#c2e699",
  "Orchards" = "#addd8e",
  "Forests" = "#006837",
  "Herbaceous vegetation associations" = "#31a354",
  "Open spaces with little or no vegetation" = "#d9f0a3",
  "Wetlands" = "#80cdc1",
  "Water" = "#67a9cf"
)
```

```{r Correlation by land cover class}

# Summarise model–reference correlation by land cover class
cor_summary <- landuse %>%
  st_drop_geometry() %>%
  group_by(class_2018) %>%
  summarise(
    n = n(),
    corr = cor(rk_mean, ref_mean, use = "complete.obs"),
    rk_mean = mean(rk_mean, na.rm = TRUE),
    ref_mean = mean(ref_mean, na.rm = TRUE),
    diff_mean = mean(rk_mean - ref_mean, na.rm = TRUE)
  ) %>%
  arrange(desc(corr))

# remove classes without valid correlations
cor_summary <- cor_summary %>% filter(!is.na(corr))

# Plot correlation by land cover class
p_landcover_corr <- ggplot(cor_summary, aes(
  x = reorder(class_2018, corr), 
  y = corr,                      
  fill = class_2018               
)) +
  geom_col(width = 0.6, color = "grey30") +                         
  geom_text(aes(label = sprintf("%.2f", corr)),         
            hjust = -0.1, size = 3, color = "black") +
  scale_fill_manual(values = landcover_colors) +                
  coord_flip() +                                                    
  geom_hline(yintercept = 0, color = "grey50", linetype = "dashed") + 
  labs(
    title = "Temperature Correlation by Land Cover Class (09 July 2023, 14:00)",
    subtitle = "Pearson’s r between RK model in °C and reference PET",
    caption = "Data: RK model output, Urban Climate Analysis Heidelberg (2023),\nUrban Atlas Land Cover/Land Use (2018), Europe, 6-yearly",
    x = NULL,
    y = "Pearson Correlation (r)"
  ) +
  theme_bw(base_size = 13) +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold", size = 14), 
    plot.subtitle = element_text(hjust = 0.5, size = 10, margin = margin(b = 8)), 
    legend.position = "none",                                          
    axis.text.y = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major.y = element_blank()
  )

# Display the plots
p_landcover_corr

# Save as PNG
ggsave("../plots/landcover_correlation_2023-07-09_14-00.png", p_landcover_corr, width = 10, height = 5, dpi = 300)
```

--------------------------------------------------------------------------------

Comparison of the monthly mean temperature surface with the 
RK temperature prediction surface for hourly means

```{r Temporal variability analysis per pixel}

# Load monthly mean RK surface
mm_july_rk  <- terra::rast("../rk_monthly_mean/rk_predictions/2023_07_rk_prediction_map.tif")

# Directory with hourly RK predictions
rk_dir <- "../rk_results_07-09-2023/rk_predictions"

# List all hourly RK raster files for July 2023
rk_files <- list.files(rk_dir, pattern = "2023-07.*_rk_prediction_map\\.tif$", full.names = TRUE)

# Stack all hourly rasters
rk_stack <- rast(rk_files)

# Pixel-wise mean temperature (hourly average over July)
rk_mean_july <- app(rk_stack, fun = mean, na.rm = TRUE)

# Pixel-wise SD (temporal variability)
rk_sd_july <- app(rk_stack, fun = sd, na.rm = TRUE)

# Coefficient of variation (relative variability)
rk_cv_july <- rk_sd_july / rk_mean_july

# Plot SD map
plot(rk_sd_july, col = viridis(20),
     main = "Hourly RK Temperature Variability (SD, July 2023)",
     xlab = "", ylab = "")

# Plot Coefficient of variation map
plot(rk_cv_july, col = viridis(20),
     main = "Relative RK Temperature Variability (CV, July 2023)",
     xlab = "", ylab = "")

# Compare monthly mean, hourly mean, and hourly SD
plot(c(mm_july_rk, rk_mean_july, rk_sd_july),
     col = viridis(20),
     main = c("Monthly Mean RK (from monthly model)",
              "Hourly Mean RK (average of all hours)",
              "Hourly Variability (SD across hours)"))
```


```{r Residual variability relative to the monthly mean RK}

# Residuals = hourly RK minus monthly mean RK
res_stack <- rk_stack - mm_july_rk

# Pixel-wise SD of residuals (temporal variability)
res_var <- app(res_stack, fun = sd, na.rm = TRUE)

# Convert to data frame for plotting
res_df <- as.data.frame(res_var, xy = TRUE, na.rm = TRUE)
names(res_df)[3] <- "residual_sd"

# Plot spatial SD map
ggplot(res_df, aes(x, y, fill = residual_sd)) +
  geom_raster() +
  scale_fill_viridis_c(name = "SD (°C)") +
  coord_equal() +
  theme_minimal() +
  labs(title = "Residual Variability (Hourly RK vs Monthly Mean RK, July 2023)")

# Extract mean SD per landcover polygon
res_var_by_lc <- terra::extract(res_var, landuse, fun = mean, na.rm = TRUE)

# Rename value column
names(res_var_by_lc)[2] <- "mean_sd"

# Add landcover class names
res_var_by_lc$class_2018 <- landuse$class_2018

# Aggregate by class
res_var_summary <- res_var_by_lc %>%
  group_by(class_2018) %>%
  summarise(mean_sd = mean(mean_sd, na.rm = TRUE)) %>%
  arrange(desc(mean_sd))

# Plot mean SD by landcover class
ggplot(res_var_summary, aes(x = reorder(class_2018, mean_sd), y = mean_sd, fill = mean_sd)) +
  geom_col() +
  coord_flip() +
  scale_fill_viridis_c(name = "SD (°C)") +
  labs(
    title = "Residual Variability by Landcover Class",
    subtitle = "Standard deviation of hourly RK deviations from monthly RK mean (July 2023)",
    x = "Landcover Class (class_2018)",
    y = "Mean SD (°C)"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    axis.text.y = element_text(size = 9),
    legend.position = "right"
  )
```